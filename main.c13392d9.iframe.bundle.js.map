{"version":3,"file":"main.c13392d9.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;AAkCA;;;;;AC1BA;;;;;;AAMA;;AAIA;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAiCA;;;AArBA;;;;AAIA;;AAmBA;;;AAZA;AACA;AACA;AACA;;;;;AAaA;;;AC7DA;;AAEA;;AAIA;;;AAIA;AACA;AACA;AACA;;AAiBA;;AAXA;;AAaA;AARA;AACA;;;AAYA;;;AC1BA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;AAMA;;;;;;;;;;AC5DA;;;ACeA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;AAMA;;;;;;;;AD5DA;AEJA;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;AAaA;;;;;;;;;ACRA;AACA;;;ACmBA;;;;;;;;;;AAYA;AAGA;;;;AAIA;;;;AAMA;;;;;AAOA;;;;;;;AASA;;;;;;AC1CA;;;;;;;;;;;;;ACEA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;ACyBA;;;AAGA;AACA;;;;;;AAQA;;;;;;;AASA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAIA;;AAEA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;AAMA;AACA;;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;AC3GA;AAGA;;;AAGA;;;;;;AAMA;;;;;;;AAOA;;;;;;;AAOA;;;;AChGA;;AAEA;AACA;;;;;;AAMA;;;AAGA;;;;AAIA;;;;;;;ACvBA;;;;;;;;;;;AAaA;;ACXA;;;;AAIA;AACA;;;;;ACeA;AACA;AACA;;;;AAMA;AACA;;;;;;AAMA;;;;;AAKA;;;;;AAKA;;;;;;;AChDA;AAGA;;;;;;;;;;;;ACiCA;AAKA;AACA;;;AAGA;AAGA;;;AClDA;AACA;;;;;;ACCA;AAGA;;;;;ACXA;;;;AC4EA;;AAEA;;;;;;;;;;;;;;;;;AAmBA;AAGA;AACA;AAIA;AAGA;AACA;AAGA;AAGA;AACA;;;;;;;;;AC8FA;;;AAKA;;AAIA;;;AAGA;;;AAKA;;;;;AAOA;;AAEA;;;;;;;;;;;;;;;;AAkBA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/JA;;;;;;;;;;;;;;;;;;AAkBA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;;;;;AAOA;;;AAGA;;;;;;AAMA;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;AAeA;AACA;;;;;AAKA;;;;AAIA;;;AAGA;;;;;;;;;;AAUA;;;AAGA;;;;;;;AAOA;;;;;;;;;AASA;AACA;;;AAGA;AACA;;;;;;;;;ACdA;;;;;;AAMA;;;AAGA;;;;AC0BA;AACA;AAIA;;;;AAIA;;;;AAIA;AASA;;;;;;;AC5JA;AACA;;;;;;;;AAQA;;;;;;;;;;;;;;AAcA;;;AAGA;;AAIA;AAGA;AACA;;;;;;AAMA;;;;;;;;;ACkGA;AACA;AAIA;;;AAGA;;;;;AAKA;AASA;;AAIA;;;;;;;;;;;;;;ACwGA;;;AAGA;;;AAGA;;AAIA;AACA;;;;AAMA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;AClRA;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;AAIA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;;;;;AAOA;;;AAGA;;;;;;AAMA;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;AAeA;AACA;;;;;AAKA;;;;AAIA;;;AAGA;;;;;;;;;;AAUA;;;AAGA;;;;;;;AAOA;;;;;;;;;AASA;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACwSA;;;AAGA;;;AAGA;;AAIA;AACA;;;;AAMA;;AAKA;;ACzdA;;AAEA;;;;;;;AAOA;;AAIA;;;;AAIA;;;;;;;;AAUA;;;;;;;;;;;;;AC6EA;;AAEA;;;;;AAcA;;;;;AAKA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvKA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;AAQA;;;;;;;;;;;;;AC+CA;AAGA;;;;;;;AASA;;;;;;;;;;AClEA;AACA;;;;;;;;;;AAUA;;;;;AAKA;;;;;;ACtCA;;AAEA;AAGA;;;AAKA;;;;;ACMA;AAGA;AACA;;AAIA;;;;;ACvEA;AAGA;;;;;AC2CA;AACA;AACA;;;;;;AC2GA;;;AAKA;;;;;;;;;AAWA;;;;;;AAMA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;ACjLA;AACA;;;;;;AAMA;;;;AAIA;;;;;AAKA;;;;ACGA;AACA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;;;AAKA;;;AAKA;;;;;;;AASA","sources":["webpack://@mtes-mct/monitor-ui__root/./.storybook/components/GlobalDecorator.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Table/SimpleTable.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Table/TableWithSelectableRows/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/GlobalStyle.ts","webpack://@mtes-mct/monitor-ui__root/./src/theme.ts","webpack://@mtes-mct/monitor-ui__root/./src/OnlyFontGlobalStyle.ts","webpack://@mtes-mct/monitor-ui__root/./src/components/Dialog/Action.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/Dialog/Body.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/Dialog/Title.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/Dialog/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/Dropdown/Item.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/Dropdown/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Button.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/IconButton.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/SideMenu/Button.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/SideMenu/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/IconBox.tsx","webpack://@mtes-mct/monitor-ui__root/./src/components/SingleTag.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Legend.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Fieldset.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/FieldError.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Label.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Tag/Disk.tsx","webpack://@mtes-mct/monitor-ui__root/./src/elements/Tag/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/Search.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DatePicker/CalendarPicker.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DateRangePicker/NumberInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DateRangePicker/DateInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DateRangePicker/RangedTimePicker.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DateRangePicker/TimeInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DatePicker/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DateRangePicker/RangeCalendarPicker.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/DateRangePicker/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/MultiCheckbox.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/MultiSelect.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/MultiRadio.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/MultiZoneEditor/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/NumberInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/CoordinatesInput/DDCoordinatesInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/CoordinatesInput/DMDCoordinatesInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/CoordinatesInput/DMSCoordinatesInput.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/CoordinatesInput/index.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/Select.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/Textarea.tsx","webpack://@mtes-mct/monitor-ui__root/./src/fields/TextInput.tsx"],"sourcesContent":["import { StrictMode } from 'react'\nimport { CustomProvider as RsuiteCustomProvider } from 'rsuite'\nimport rsuiteFrFr from 'rsuite/locales/fr_FR'\nimport { createGlobalStyle, ThemeProvider } from 'styled-components'\n\nimport { GlobalStyle, THEME } from '../../src'\n\nimport type { ComponentStory } from '@storybook/react'\n\nconst UntypedGlobalStyle = GlobalStyle as any\nconst UntypedThemeProvider = ThemeProvider as any\n\nconst CustomGlobalStyle: any = createGlobalStyle`\n  html,\n  body.sb-show-main.sb-main-padded {\n    height: 100%;\n    padding: 0;\n    width: 640px;\n  }\n\n  code {\n    background-color: #1e1e1e;\n    color: #ffffff;\n    font-size: 12px;\n    padding: 2px 6px;\n    vertical-align: 1px;\n  }\n\n  #root {\n    height: 100%;\n    width: 100%;\n  }\n`\n\nexport function GlobalDecorator(Story: ComponentStory<any>) {\n  return (\n    <GlobalDecoratorWrapper>\n      <Story />\n    </GlobalDecoratorWrapper>\n  )\n}\n\nexport function GlobalDecoratorWrapper({ children }) {\n  return (\n    <StrictMode>\n      <UntypedThemeProvider theme={THEME}>\n        <UntypedGlobalStyle />\n        <CustomGlobalStyle />\n\n        <RsuiteCustomProvider locale={rsuiteFrFr}>{children}</RsuiteCustomProvider>\n      </UntypedThemeProvider>\n    </StrictMode>\n  )\n}\n","import styled from 'styled-components'\n\nconst Table = styled.table`\n  width: 100%;\n  table-layout: auto;\n  overflow: auto;\n  border-collapse: separate;\n`\nconst Head = styled.thead`\n  position: sticky;\n  top: 0;\n  z-index: 1;\n\n  th:first-child {\n    border-left: 1px solid ${p => p.theme.color.lightGray};\n  }\n`\n\nconst SortContainer = styled.div`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  cursor: default;\n\n  &.cursor-pointer {\n    cursor: pointer;\n  }\n`\nconst Th = styled.th`\n  background-color: ${p => p.theme.color.gainsboro};\n  border-top: 1px solid ${p => p.theme.color.lightGray};\n  border-bottom: 1px solid ${p => p.theme.color.lightGray};\n  border-right: 1px solid ${p => p.theme.color.lightGray};\n  color: ${p => p.theme.color.slateGray};\n  font-size: 13px;\n  font-weight: 500;\n  padding: 10px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n`\n\nconst BodyTr = styled.tr`\n  :hover {\n    > td {\n      background-color: ${p => p.theme.color.blueYonder[25]};\n    }\n  }\n  td:first-child {\n    border-left: 1px solid ${p => p.theme.color.lightGray};\n  }\n`\n\nconst Td = styled.td<{ $isCenter: boolean }>`\n  font-size: 13px;\n  font-weight: 500;\n  color: ${p => p.theme.color.gunMetal};\n  text-align: ${p => (p.$isCenter ? 'center' : 'left')};\n  border-bottom: 1px solid ${p => p.theme.color.lightGray};\n  border-right: 1px solid ${p => p.theme.color.lightGray};\n  overflow: hidden;\n  padding: 10px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n`\n\nexport const SimpleTable = {\n  BodyTr,\n  Head,\n  SortContainer,\n  Table,\n  Td,\n  Th\n}\n","import styled from 'styled-components'\n\nimport { RowCheckbox } from './RowCheckbox'\nimport { SimpleTable } from '../SimpleTable'\n\nexport { RowCheckbox }\n\nconst Table = styled(SimpleTable.Table)`\n  border-collapse: separate;\n  border-spacing: 0 5px;\n`\nconst Head = styled(SimpleTable.Head)`\n  th:last-child {\n    border-right: 1px solid ${p => p.theme.color.lightGray};\n  }\n`\n\nconst SortContainer = styled(SimpleTable.SortContainer)`\n  justify-content: start;\n  gap: 8px;\n`\nconst Th = styled(SimpleTable.Th)`\n  background-color: ${p => p.theme.color.white};\n  border-top: 1px solid ${p => p.theme.color.lightGray};\n  border-bottom: 1px solid ${p => p.theme.color.lightGray};\n  border-right: none;\n`\n\nconst BodyTr = styled(SimpleTable.BodyTr)`\n  td:last-child {\n    border-right: 1px solid ${p => p.theme.color.lightGray};\n  }\n`\n\nconst Td = styled(SimpleTable.Td)`\n  background-color: ${p => p.theme.color.cultured};\n  border-top: 1px solid ${p => p.theme.color.lightGray};\n  border-right: none;\n  padding: 4px 10px;\n`\n\nexport const TableWithSelectableRows = {\n  BodyTr,\n  Head,\n  RowCheckbox,\n  SortContainer,\n  Table,\n  Td,\n  Th\n}\n","import { createGlobalStyle } from 'styled-components'\n\n// @ts-ignore\nimport MarianneBold from './assets/fonts/Marianne-Bold.woff2'\n// @ts-ignore\nimport MarianneBoldItalic from './assets/fonts/Marianne-Bold_Italic.woff2'\n// @ts-ignore\nimport MarianneLight from './assets/fonts/Marianne-Light.woff2'\n// @ts-ignore\nimport MarianneLightItalic from './assets/fonts/Marianne-Light_Italic.woff2'\n// @ts-ignore\nimport MarianneMedium from './assets/fonts/Marianne-Medium.woff2'\n// @ts-ignore\nimport MarianneMediumItalic from './assets/fonts/Marianne-Medium_Italic.woff2'\n// @ts-ignore\nimport MarianneRegular from './assets/fonts/Marianne-Regular.woff2'\n// @ts-ignore\nimport MarianneItalic from './assets/fonts/Marianne-Regular_Italic.woff2'\n\nexport const GlobalStyle = createGlobalStyle`\n  @font-face {\n    font-family: Marianne;\n    src: local('Marianne'), local('Marianne-Regular'), url(${MarianneRegular}) format('woff2');\n    font-weight: normal;\n  }\n\n    @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Thin'), url(${MarianneLight}) format('woff2');\n    font-weight: 300;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src:local('Marianne-Medium'), url(${MarianneMedium}) format('woff2');\n    font-weight: 500;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Medium_Italic'), url(${MarianneMediumItalic}) format('woff2');\n    font-weight: 500;\n    font-style: italic;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Thin_Italic'), url(${MarianneLightItalic}) format('woff2');\n    font-weight: lighter;\n    font-style: italic;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src:local('Marianne-Regular_Italic'), url(${MarianneItalic}) format('woff2');\n    font-weight: normal;\n    font-style: italic;\n  }\n\n    @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Bold'), url(${MarianneBold}) format('woff2');\n    font-weight: 700;\n  }\n\n    @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Bold_Italic'), url(${MarianneBoldItalic}) format('woff2');\n    font-style: italic;\n    font-weight: 700;\n  }\n\n  body {\n    font-family: Marianne, sans-serif;\n    font-size: 16px;\n    line-height: 1.3846;\n  }\n`\n","/* eslint-disable sort-keys-fix/sort-keys-fix, typescript-sort-keys/interface */\n\nimport type { PartialDeep } from 'type-fest'\n\nexport type Theme = typeof THEME\nexport type PartialTheme = PartialDeep<Theme>\n\nexport const THEME = {\n  // https://xd.adobe.com/view/b6d4c472-3fbe-4dec-9f14-38fe03872a3e-e387/screen/b9bdc1ba-5f07-4c4f-bd44-2d38b2c6f663/specs/\n  color: {\n    /** INTERFACE COLORS */\n\n    // Neutral Colors\n    gunMetal: '#282F3E',\n    // TODO Make that charcoal object 100 & 50\n    charcoal: '#3B4559',\n    charcoalShadow: 'rgba(59, 69, 89, 0.5)',\n    slateGray: '#707785',\n    lightGray: '#CCCFD6',\n    gainsboro: '#E5E5EB',\n    cultured: '#F7F7FA',\n    white: '#FFFFFF',\n\n    // Accentuation Colors\n    blueYonder: {\n      25: '#D4DDE7',\n      100: '#567A9E'\n    },\n    blueGray: {\n      100: '#5697D2',\n      25: '#D4E5F4'\n    },\n    babyBlueEyes: '#99C9FF',\n\n    // Notification Colors\n    mediumSeaGreen: '#29B361',\n    goldenPoppy: '#FAC11A',\n    maximumRed: '#E1000F',\n\n    /** CONTEXTUAL COLORS */\n\n    // Mission status\n    yellowGreen: '#8CC800',\n\n    // Risk Factor\n    cadetGray: '#8E9A9F',\n    grullo: '#B89B8C',\n    copperRed: '#CF6A4E',\n    chineseRed: '#A13112',\n\n    // Vessel Track\n    darkCornflowerBlue: '#2A4670',\n    jungleGreen: '#1C9B7B',\n\n    // Beacon Malfunction\n    powderBlue: '#9ED7D9',\n    wheat: '#EDD6A4',\n    // goldenPoppy: '#FAC11A',\n    // maximumRed: '#E1000F',\n    // charcoal: '#3B4559',\n    // mediumSeaGreen: '#29B361',\n    opal: '#A5BCC0',\n\n    // Regulation Areas\n    yaleBlue: '#295375',\n    queenBlue: '#367096',\n    glaucous: '#6284A6',\n    blueNcs: '#3690C0',\n    iceberg: '#67A9CF',\n    lightSteelBlue: '#9AB4D6',\n    lightPeriwinkle: '#CDCFEA',\n    aliceBlue: '#EBF0F4',\n    lightBlue: '#B9DDE5',\n    lightCyan: '#C7EAE5', // deprecated ?\n    middleBlueGreen: '#91CFC9', // deprecated ?\n    verdigris: '#56B3AB', // deprecated ?\n    viridianGreen: '#01A29D', // deprecated ?\n    paoloVeroneseGreen: '#21977F', // deprecated ?\n    skobeloff: '#01686B', // deprecated ?\n    blueSapphire: '#01536A', // deprecated ?\n    indigoDye: '#033E54', // deprecated ?\n    skyBlue: '#77C1DE',\n    frenchBlue: '#2E75AB',\n    prussianBlue: '#003E54',\n    lightCoral: '#FA8282',\n\n    // AMP Zones\n    brownSugar: '#B26A53',\n    rust: '#B1502F',\n    burntSienna: '#D46E49',\n    persianOrange: '#D6814F',\n    jasper: '#DB503D',\n    bittersweet: '#F0755C',\n    coral: '#F78A69',\n    peach: '#FCB394',\n    apricot: '#F0C1A1',\n    melon: '#E7A58D',\n    paleDogwood: '#F8D7CE',\n    seashell: '#FCECE4'\n  }\n}\n","import { createGlobalStyle } from 'styled-components'\n\n// @ts-ignore\nimport MarianneBold from './assets/fonts/Marianne-Bold.woff2'\n// @ts-ignore\nimport MarianneBoldItalic from './assets/fonts/Marianne-Bold_Italic.woff2'\n// @ts-ignore\nimport MarianneLight from './assets/fonts/Marianne-Light.woff2'\n// @ts-ignore\nimport MarianneLightItalic from './assets/fonts/Marianne-Light_Italic.woff2'\n// @ts-ignore\nimport MarianneMedium from './assets/fonts/Marianne-Medium.woff2'\n// @ts-ignore\nimport MarianneMediumItalic from './assets/fonts/Marianne-Medium_Italic.woff2'\n// @ts-ignore\nimport MarianneRegular from './assets/fonts/Marianne-Regular.woff2'\n// @ts-ignore\nimport MarianneItalic from './assets/fonts/Marianne-Regular_Italic.woff2'\n\nexport const OnlyFontGlobalStyle = createGlobalStyle`\n  @font-face {\n    font-family: Marianne;\n    src: local('Marianne'), local('Marianne-Regular'), url(${MarianneRegular}) format('woff2');\n    font-weight: normal;\n  }\n\n    @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Thin'), url(${MarianneLight}) format('woff2');\n    font-weight: 300;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src:local('Marianne-Medium'), url(${MarianneMedium}) format('woff2');\n    font-weight: 500;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Medium_Italic'), url(${MarianneMediumItalic}) format('woff2');\n    font-weight: 500;\n    font-style: italic;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Thin_Italic'), url(${MarianneLightItalic}) format('woff2');\n    font-weight: lighter;\n    font-style: italic;\n  }\n\n  @font-face {\n    font-family: Marianne;\n    src:local('Marianne-Regular_Italic'), url(${MarianneItalic}) format('woff2');\n    font-weight: normal;\n    font-style: italic;\n  }\n\n    @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Bold'), url(${MarianneBold}) format('woff2');\n    font-weight: 700;\n  }\n\n    @font-face {\n    font-family: Marianne;\n    src: local('Marianne-Bold_Italic'), url(${MarianneBoldItalic}) format('woff2');\n    font-style: italic;\n    font-weight: 700;\n  }\n\n  body {\n    font-family: Marianne, sans-serif;\n  }\n`\n","import styled from 'styled-components'\n\nexport const Action = styled.div`\n  background-color: ${p => p.theme.color.white};\n  border-bottom-left-radius: 2px;\n  border-bottom-right-radius: 2px;\n  display: flex;\n  flex-direction: column-reverse;\n  padding: 8px 8px 8px 8px;\n  @media (min-width: 740px) {\n    align-items: center;\n    flex-direction: row;\n    justify-content: center;\n    padding: 48px 8px 48px 8px;\n  }\n\n  > button {\n    margin-bottom: 2px;\n  }\n  @media (min-width: 740px) {\n    > button {\n      margin-bottom: 0;\n      margin-right: 2px;\n    }\n  }\n`\n","import styled from 'styled-components'\n\nexport const Body = styled.div`\n  background-color: ${p => p.theme.color.white};\n  border-top-left-radius: 2px;\n  border-top-right-radius: 2px;\n  display: flex;\n  flex-direction: column;\n  padding: 8px 8px 8px 8px;\n  text-align: center;\n  @media (min-width: 740px) {\n    padding: 48px 8px 8px 8px;\n    text-align: center;\n  }\n\n  > p {\n    color: ${p => p.theme.color.slateGray};\n    padding-top: 2px;\n  }\n`\n","import styled from 'styled-components'\n\nexport const Title = styled.h4`\n  font-size: 125%;\n  font-weight: 500;\n  line-height: 48px;\n  padding-bottom: 2px;\n  height: 48px;\n  color: ${p => p.theme.color.white};\n  background-color: ${p => p.theme.color.charcoal};\n  text-align: center;\n`\n","import classnames from 'classnames'\nimport styled from 'styled-components'\n\nimport { Action } from './Action'\nimport { Body } from './Body'\nimport { Title } from './Title'\nimport { stopMouseEventPropagation } from '../../utils/stopMouseEventPropagation'\n\nimport type { HTMLAttributes } from 'react'\n\nexport type DialogProps = HTMLAttributes<HTMLDivElement> & {\n  isAbsolute?: boolean\n}\nexport function RawDialog({ children, className, isAbsolute = false, ...nativeProps }: DialogProps) {\n  const controlledClassName = classnames('Component-Dialog', className)\n\n  return (\n    <Box $isAbsolute={isAbsolute} className={controlledClassName} onClick={stopMouseEventPropagation} {...nativeProps}>\n      <Overlay $isAbsolute={isAbsolute} />\n\n      <Window $isAbsolute={isAbsolute}>{children}</Window>\n    </Box>\n  )\n}\n\nexport const Box = styled.div<{\n  $isAbsolute: boolean\n}>`\n  position: ${p => (p.$isAbsolute ? 'absolute' : 'fixed')};\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  overflow-y: auto;\n  z-index: 9000;\n`\n\nconst Overlay = styled.div<{\n  $isAbsolute: boolean\n}>`\n  background-color: ${p => p.theme.color.charcoal};\n  bottom: 0;\n  left: 0;\n  opacity: 0.53;\n  position: ${p => (p.$isAbsolute ? 'absolute' : 'fixed')};\n  right: 0;\n  top: 0;\n  z-index: 1;\n`\n\nconst Window = styled.div<{\n  $isAbsolute: boolean\n}>`\n  border-radius: 2px;\n  bottom: 100px;\n  box-shadow: 4px;\n  max-width: 32rem;\n  position: ${p => (p.$isAbsolute ? 'absolute' : 'fixed')};\n  width: calc(100% - 2 * 8px);\n  z-index: 1;\n  @media (min-width: 740px) {\n    bottom: auto;\n    min-width: 586px;\n  }\n`\n\nRawDialog.displayName = 'Dialog'\n\nexport const Dialog = Object.assign(RawDialog, {\n  Action,\n  Body,\n  Title\n})\n","import { useMemo } from 'react'\nimport { Dropdown as RsuiteDropdown } from 'rsuite'\nimport styled from 'styled-components'\n\nimport type { IconProps } from '../../types'\nimport type { FunctionComponent } from 'react'\nimport type { DropdownMenuItemProps as RsuiteDropdownMenuItemProps } from 'rsuite'\n\nexport type DropdownItemProps = Omit<RsuiteDropdownMenuItemProps, 'as' | 'icon'> & {\n  Icon?: FunctionComponent<IconProps>\n}\nexport function Item({ Icon, ...originalProps }: DropdownItemProps) {\n  const icon = useMemo(() => (Icon ? <Icon size={20} /> : undefined), [Icon])\n  const hasIcon = useMemo(() => Boolean(Icon), [Icon])\n\n  return <StyledDropdownItem $hasIcon={hasIcon} icon={icon} {...originalProps} />\n}\n\n// TODO We need to split that into multiple styled components as done in `<Button />`.\nconst StyledDropdownItem = styled(RsuiteDropdown.Item)<{\n  $hasIcon: boolean\n}>`\n  align-items: center;\n  display: flex;\n  font-size: 13px;\n  line-height: 1;\n  padding: 12px;\n  padding: ${p => (p.$hasIcon ? '7px' : '11px')} 12px ${p => (p.$hasIcon ? '9px' : '14px')};\n\n  &:not(:last-child) {\n    border-bottom: 1px solid var(--lightGray);\n  }\n\n  /* SVG Icon Components are wrapped within a <div /> */\n  > div {\n    margin-top: 1px;\n  }\n`\n","import classnames from 'classnames'\nimport { useMemo } from 'react'\nimport { Dropdown as RsuiteDropdown } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Item } from './Item'\n\nimport type { DropdownItemProps } from './Item'\nimport type { IconProps } from '../../types'\nimport type { FunctionComponent } from 'react'\nimport type { DropdownProps as RsuiteDropdownProps } from 'rsuite'\n\nexport type DropdownProps = Omit<RsuiteDropdownProps, 'as' | 'icon'> & {\n  Icon?: FunctionComponent<IconProps>\n}\nfunction RawDropdown({ className, Icon, ...originalProps }: DropdownProps) {\n  const controlledClassName = classnames('Component-Dropdow', className)\n  const icon = useMemo(() => (Icon ? <Icon size={20} /> : undefined), [Icon])\n  const hasIcon = useMemo(() => Boolean(Icon), [Icon])\n\n  return <StyledDropdown $hasIcon={hasIcon} className={controlledClassName} icon={icon} {...originalProps} />\n}\n\n// TODO We need to split into multiple styled components as done in `<Button />`.\nconst StyledDropdown = styled(RsuiteDropdown)<{\n  $hasIcon: boolean\n}>`\n  .rs-btn {\n    align-items: center;\n    background-color: ${p => p.theme.color.charcoal};\n    border: solid 1px ${p => p.theme.color.charcoal};\n    color: ${p => p.theme.color.gainsboro};\n    display: flex;\n    font-size: 13px;\n    padding: ${p => (p.$hasIcon ? '4px' : '5px')} 12px ${p => (p.$hasIcon ? '5px' : '7px')};\n\n    :hover {\n      background-color: ${p => p.theme.color.blueYonder['100']};\n      border: 1px solid ${p => p.theme.color.blueYonder['100']};\n      color: ${p => p.theme.color.white};\n    }\n\n    :active {\n      background-color: ${p => p.theme.color.blueGray['100']};\n      border: 1px solid ${p => p.theme.color.blueGray['100']};\n      color: ${p => p.theme.color.white};\n    }\n\n    :disabled {\n      background-color: ${p => p.theme.color.lightGray};\n      border: 1px solid ${p => p.theme.color.lightGray};\n      color: ${p => p.theme.color.cultured};\n    }\n\n    /* SVG Icon Components are wrapped within a <div /> */\n    > div {\n      margin: 1px 8px 0 0;\n    }\n\n    > svg {\n      display: none;\n    }\n  }\n\n  > .rs-dropdown-menu {\n    border-radius: 0;\n    padding: 0;\n  }\n\n  svg.rs-dropdown-item-menu-icon {\n    vertical-align: middle;\n    margin-right: 10px;\n  }\n`\n\nRawDropdown.displayName = 'Dropdown'\n\nexport const Dropdown: FunctionComponent<DropdownProps> & {\n  Item: FunctionComponent<DropdownItemProps>\n} = Object.assign(RawDropdown, {\n  Item\n})\n\nexport { type DropdownItemProps }\n","import classnames from 'classnames'\nimport { useCallback, useMemo, type MouseEvent, type ButtonHTMLAttributes, type FunctionComponent } from 'react'\nimport styled from 'styled-components'\n\nimport { Accent, Size } from '../constants'\nimport { type IconProps } from '../types'\nimport { stopMouseEventPropagation } from '../utils/stopMouseEventPropagation'\n\nconst ICON_SIZE: Record<Size, number> = {\n  [Size.LARGE]: 20,\n  [Size.NORMAL]: 20,\n  [Size.SMALL]: 12\n}\n\nexport type ButtonProps = Omit<ButtonHTMLAttributes<HTMLButtonElement>, 'children'> & {\n  Icon?: FunctionComponent<IconProps> | undefined\n  accent?: Accent | undefined\n  children?: string | undefined\n  isFullWidth?: boolean | undefined\n  size?: Size | undefined\n  /** Prevent onClick event propagation. */\n  withUnpropagatedClick?: boolean | undefined\n}\nexport function Button({\n  accent = Accent.PRIMARY,\n  children,\n  className,\n  Icon,\n  isFullWidth = false,\n  onClick,\n  size = Size.NORMAL,\n  type = 'button',\n  withUnpropagatedClick = false,\n  ...nativeProps\n}: ButtonProps) {\n  const handleClick = useCallback(\n    (event: MouseEvent<HTMLButtonElement>) => {\n      if (withUnpropagatedClick) {\n        stopMouseEventPropagation(event)\n      }\n\n      if (onClick) {\n        onClick(event)\n      }\n    },\n    [onClick, withUnpropagatedClick]\n  )\n\n  const commonChildren = useMemo(\n    () => (\n      <>\n        {Icon && <Icon size={ICON_SIZE[size]} />}\n        {children && <ButtonLabel>{children}</ButtonLabel>}\n      </>\n    ),\n    [children, Icon, size]\n  )\n\n  const commonProps = useMemo(\n    () => ({\n      as: StyledButton,\n      children: commonChildren,\n      className: classnames('Element-Button', className),\n      isFullWidth,\n      onClick: handleClick,\n      size,\n      type,\n      ...nativeProps\n    }),\n    [className, commonChildren, handleClick, isFullWidth, nativeProps, size, type]\n  )\n\n  switch (accent) {\n    case Accent.SECONDARY:\n      return <SecondaryButton {...commonProps} />\n\n    case Accent.TERTIARY:\n      return <TertiaryButton {...commonProps} />\n\n    default:\n      return <PrimaryButton {...commonProps} />\n  }\n}\n\nconst FONT_SIZE: Record<Size, string> = {\n  [Size.LARGE]: '13px',\n  [Size.NORMAL]: '13px',\n  [Size.SMALL]: '11px'\n}\nconst PADDING: Record<Size, string> = {\n  [Size.LARGE]: '6px 12px',\n  [Size.NORMAL]: '6px 12px',\n  [Size.SMALL]: '5px 8px 4px'\n}\nconst StyledButton = styled.button<{\n  isFullWidth: boolean\n  size: Size\n}>`\n  align-items: center;\n  display: inline-flex;\n  font-size: ${p => FONT_SIZE[p.size]};\n  justify-content: center;\n  max-width: 100%;\n  padding: ${p => PADDING[p.size]};\n  width: ${p => (p.isFullWidth ? '100%' : 'auto')};\n\n  /* SVG Icon Components are wrapped within a <div /> */\n  > div {\n    margin-right: 5px;\n  }\n`\n\nconst ButtonLabel = styled.span`\n  line-height: 1.3846;\n  margin-top: -3px;\n  min-width: 0;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n`\n\nexport const PrimaryButton = styled.button`\n  background-color: ${p => p.theme.color.charcoal};\n  border: 1px solid ${p => p.theme.color.charcoal};\n  color: ${p => p.theme.color.gainsboro};\n\n  :hover,\n  &._hover {\n    background-color: ${p => p.theme.color.blueYonder['100']};\n    border: 1px solid ${p => p.theme.color.blueYonder['100']};\n    color: ${p => p.theme.color.white};\n  }\n\n  :active,\n  &._active {\n    background-color: ${p => p.theme.color.blueGray['100']};\n    border: 1px solid ${p => p.theme.color.blueGray['100']};\n    color: ${p => p.theme.color.white};\n  }\n\n  :disabled,\n  &._disabled {\n    background-color: ${p => p.theme.color.lightGray};\n    border: 1px solid ${p => p.theme.color.lightGray};\n    color: ${p => p.theme.color.cultured};\n  }\n`\n\nexport const SecondaryButton = styled.button`\n  background-color: transparent;\n  border: 1px solid ${p => p.theme.color.charcoal};\n  color: ${p => p.theme.color.charcoal};\n\n  :hover,\n  &._hover {\n    background-color: ${p => p.theme.color.blueYonder['25']};\n    border: 1px solid ${p => p.theme.color.blueYonder['100']};\n    color: ${p => p.theme.color.blueYonder['100']};\n  }\n\n  :active,\n  &._active {\n    background-color: ${p => p.theme.color.blueGray['25']};\n    border: 1px solid ${p => p.theme.color.blueGray['100']};\n    color: ${p => p.theme.color.blueGray['100']};\n  }\n\n  :disabled,\n  &._disabled {\n    background-color: transparent;\n    border: 1px solid ${p => p.theme.color.lightGray};\n    color: ${p => p.theme.color.lightGray};\n  }\n`\n\nexport const TertiaryButton = styled.button`\n  background-color: ${p => p.theme.color.white};\n  border: 1px solid ${p => p.theme.color.white};\n  color: ${p => p.theme.color.charcoal};\n\n  :hover,\n  &._hover {\n    background-color: ${p => p.theme.color.blueYonder['25']};\n    border: 1px solid ${p => p.theme.color.blueYonder['25']};\n    color: ${p => p.theme.color.blueYonder['100']};\n  }\n\n  :active,\n  &._active {\n    background-color: ${p => p.theme.color.blueGray['25']};\n    border: 1px solid ${p => p.theme.color.blueGray['100']};\n    color: ${p => p.theme.color.blueGray['100']};\n  }\n\n  :disabled,\n  &._disabled {\n    background-color: ${p => p.theme.color.white};\n    border: 1px solid ${p => p.theme.color.lightGray};\n    color: ${p => p.theme.color.lightGray};\n  }\n`\n","import classnames from 'classnames'\nimport { useMemo, type MouseEvent, type ButtonHTMLAttributes, type FunctionComponent, useCallback } from 'react'\nimport styled from 'styled-components'\n\nimport { PrimaryButton, SecondaryButton } from './Button'\nimport { Accent, Size } from '../constants'\nimport { type IconProps } from '../types'\nimport { stopMouseEventPropagation } from '../utils/stopMouseEventPropagation'\n\nconst ICON_SIZE_IN_PX: Record<Size, number> = {\n  [Size.LARGE]: 26,\n  [Size.NORMAL]: 20,\n  [Size.SMALL]: 14\n}\n\nexport type IconButtonProps = Omit<ButtonHTMLAttributes<HTMLButtonElement>, 'children'> & {\n  Icon: FunctionComponent<IconProps>\n  accent?: Accent | undefined\n  color?: string | undefined\n  /** In pixels, override `size` prop default values. */\n  iconSize?: number | undefined\n  size?: Size | undefined\n  /** Prevent onClick event propagation. */\n  withUnpropagatedClick?: boolean | undefined\n}\nexport function IconButton({\n  accent = Accent.PRIMARY,\n  className,\n  color,\n  Icon,\n  iconSize,\n  onClick,\n  size = Size.NORMAL,\n  type = 'button',\n  withUnpropagatedClick = false,\n  ...nativeProps\n}: IconButtonProps) {\n  const handleClick = useCallback(\n    (event: MouseEvent<HTMLButtonElement>) => {\n      if (withUnpropagatedClick) {\n        stopMouseEventPropagation(event)\n      }\n\n      if (onClick) {\n        onClick(event)\n      }\n    },\n    [onClick, withUnpropagatedClick]\n  )\n\n  const commonChildren = useMemo(\n    () => <Icon color={color} size={iconSize || ICON_SIZE_IN_PX[size]} />,\n    [color, Icon, iconSize, size]\n  )\n\n  const commonProps = useMemo(\n    () => ({\n      children: commonChildren,\n      className: classnames('Element-IconButton', className),\n      onClick: handleClick,\n      size,\n      type,\n      ...nativeProps\n    }),\n    [className, commonChildren, handleClick, nativeProps, size, type]\n  )\n\n  switch (accent) {\n    case Accent.SECONDARY:\n      return <SecondaryButton as={StyledButton} {...commonProps} />\n\n    case Accent.TERTIARY:\n      return <TertiaryButton as={StyledButton} {...commonProps} />\n\n    default:\n      return <PrimaryButton as={StyledButton} {...commonProps} />\n  }\n}\n\nconst PADDING: Record<Size, string> = {\n  [Size.LARGE]: '7px',\n  [Size.NORMAL]: '5px',\n  [Size.SMALL]: '3px'\n}\n\nconst StyledButton = styled.button<{\n  size: Size\n}>`\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  padding: ${p => PADDING[p.size]};\n`\n\nconst TertiaryButton = styled.button`\n  background-color: transparent;\n  border: 1px solid transparent;\n  color: ${p => p.theme.color.charcoal};\n\n  :hover,\n  &._hover {\n    background-color: transparent;\n    border: 1px solid transparent;\n    color: ${p => p.theme.color.blueYonder['100']};\n  }\n\n  :active,\n  &._active {\n    background-color: transparent;\n    border: 1px solid transparent;\n    color: ${p => p.theme.color.blueGray['100']};\n  }\n\n  :disabled,\n  &._disabled {\n    background-color: transparent;\n    border: 1px solid transparent;\n    color: ${p => p.theme.color.lightGray};\n  }\n`\n","import styled from 'styled-components'\n\nimport { IconButton, type IconButtonProps } from '../../elements/IconButton'\n\nimport type { IconProps } from '../../types'\nimport type { FunctionComponent } from 'react'\n\ntype SideMenuButtonProps = IconButtonProps & {\n  Icon: FunctionComponent<IconProps>\n  isActive: boolean\n  title: string\n}\n\nexport function Button({ Icon, isActive, title, ...originalProps }: SideMenuButtonProps) {\n  return <MenuButton $isActive={isActive} Icon={Icon} iconSize={26} role=\"menuitem\" title={title} {...originalProps} />\n}\n\nconst MenuButton = styled(IconButton)<{\n  $isActive?: boolean\n}>`\n  animation: none;\n  background: ${p => (p.$isActive ? p.theme.color.blueGray[100] : 'none')};\n  border: 0;\n  border-bottom: solid 0.5px ${p => p.theme.color.slateGray};\n  color: ${p => (p.$isActive ? p.theme.color.white : p.theme.color.gainsboro)};\n  padding: 18px;\n  height: 64px;\n\n  :hover,\n  :focus {\n    background: ${p => (p.$isActive ? p.theme.color.blueGray[100] : 'rgba(255, 255, 255, 0.125)')};\n    border: 0;\n    border: none;\n    color: ${p => p.theme.color.white};\n  }\n\n  :first-child {\n    border-top: solid 0.5px ${p => p.theme.color.slateGray};\n\n    :hover {\n      border: none;\n    }\n  }\n`\n","import styled from 'styled-components'\n\nimport { Button } from './Button'\n\nimport type { ReactNode } from 'react'\n\nexport type SideMenuProps = {\n  children: ReactNode\n}\nexport function Menu({ children }: SideMenuProps) {\n  return <Wrapper role=\"menu\">{children}</Wrapper>\n}\n\nconst Wrapper = styled.div`\n  background-color: ${p => p.theme.color.charcoal};\n  box-sizing: border-box;\n  display: flex;\n  height: 100vh;\n  flex-direction: column;\n  width: 64px;\n  padding: 64px 0 0;\n\n  * {\n    box-sizing: border-box;\n  }\n`\n\nMenu.displayName = 'SideMenu'\n\nexport const SideMenu = Object.assign(Menu, {\n  Button\n})\n","import styled from 'styled-components'\n\nimport type { HTMLAttributes } from 'react'\n\nexport type IconBoxProps = HTMLAttributes<HTMLDivElement> & {\n  $color?: string | undefined\n  /** In pixels */\n  $size?: number | undefined\n}\n/**\n * Internal component used to wrap SVG icon components\n */\nexport const IconBox = styled.div.attrs<IconBoxProps, IconBoxProps>(() => ({\n  className: 'Element-IconBox'\n}))`\n  display: inline-block;\n  color: ${p => p.$color ?? 'inherit'};\n\n  > svg {\n    display: block;\n    height: ${p => p.$size ?? 20}px;\n    width: ${p => p.$size ?? 20}px;\n  }\n`\n","import classnames from 'classnames'\nimport { type HTMLAttributes, useCallback } from 'react'\nimport styled from 'styled-components'\n\nimport { Accent } from '../constants'\nimport { IconButton } from '../elements/IconButton'\nimport { Close } from '../icons'\n\nimport type { Promisable } from 'type-fest'\n\nexport type SingleTagProps = HTMLAttributes<HTMLDivElement> & {\n  children: string\n  onDelete: () => Promisable<void>\n}\nexport function SingleTag({ children, className, onDelete, ...nativeProps }: SingleTagProps) {\n  const controlledClassName = classnames('Component-SingleTag', className)\n\n  const handleDelete = useCallback(() => {\n    if (onDelete) {\n      onDelete()\n    }\n  }, [onDelete])\n\n  return (\n    <Box className={controlledClassName} {...nativeProps}>\n      <Text>{children}</Text>\n      <StyledIconButton accent={Accent.TERTIARY} Icon={Close} iconSize={10} onClick={handleDelete} />\n    </Box>\n  )\n}\n\nconst Box = styled.div`\n  align-items: center;\n  display: inline-flex;\n`\n\nconst Text = styled.span`\n  background-color: ${p => p.theme.color.lightGray};\n  color: ${p => p.theme.color.gunMetal};\n  font-size: 13px;\n  line-height: 1.3846;\n  padding: 3px 8px 5px;\n`\n\nconst StyledIconButton = styled(IconButton)`\n  background-color: ${p => p.theme.color.lightGray};\n  margin-left: 1px;\n  padding: 7px;\n\n  :hover,\n  &._hover {\n    background-color: ${p => p.theme.color.lightGray};\n  }\n\n  :active,\n  &._active {\n    background-color: ${p => p.theme.color.lightGray};\n  }\n\n  :disabled,\n  &._disabled {\n    background-color: ${p => p.theme.color.lightGray};\n  }\n`\n","import classnames from 'classnames'\nimport styled from 'styled-components'\n\nimport type { HTMLAttributes } from 'react'\n\nexport type LegendProps = HTMLAttributes<HTMLLegendElement> & {\n  disabled?: boolean | undefined\n  hasError?: boolean | undefined\n  isHidden?: boolean | undefined\n}\nexport const Legend = styled.legend.attrs<LegendProps, LegendProps>(props => ({\n  className: classnames('Element-Legend', props.className)\n}))`\n  color: ${p =>\n    // eslint-disable-next-line no-nested-ternary\n    p.disabled ? p.theme.color.lightGray : p.hasError ? p.theme.color.maximumRed : p.theme.color.slateGray};\n  display: ${p => (p.isHidden ? 'none' : 'block')};\n  font-size: 13px;\n  line-height: 1.3846;\n  margin-bottom: 4px;\n  padding: 0;\n`\n","import classnames from 'classnames'\nimport { type FieldsetHTMLAttributes, useMemo } from 'react'\nimport styled, { css } from 'styled-components'\n\nimport { Legend } from './Legend'\n\nexport type FieldsetProps = Omit<FieldsetHTMLAttributes<HTMLFieldSetElement>, 'defaultValue' | 'onChange' | 'value'> & {\n  hasBorder?: boolean | undefined\n  hasError?: boolean | undefined\n  isLegendHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  legend?: string | undefined\n}\nexport function Fieldset({\n  children,\n  className,\n  hasBorder = false,\n  hasError = false,\n  isLegendHidden = false,\n  isLight = false,\n  legend,\n  ...nativeProps\n}: FieldsetProps) {\n  const hasLegend = useMemo(() => Boolean(legend), [legend])\n\n  return (\n    <Box className={classnames('Element-Fieldset', className)} {...nativeProps}>\n      {legend && (\n        <Legend disabled={nativeProps.disabled} hasError={hasError} isHidden={isLegendHidden}>\n          {legend}\n        </Legend>\n      )}\n\n      <InnerBox $hasBorder={hasBorder} $hasLegend={hasLegend} $isLight={isLight}>\n        {children}\n      </InnerBox>\n    </Box>\n  )\n}\n\nconst Box = styled.fieldset`\n  align-items: flex-start;\n  border: 0;\n  display: flex;\n  flex-direction: column;\n  margin: 0;\n  padding: 0;\n`\n\nconst InnerBox = styled.div<{\n  $hasBorder: boolean\n  $hasLegend: boolean\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : 'transparent')};\n  padding: ${p => (p.$hasBorder || p.$isLight ? '16px' : 0)};\n  width: 100%;\n\n  ${p =>\n    p.$hasBorder &&\n    css`\n      border: solid 1px ${p.$isLight ? p.theme.color.white : p.theme.color.gainsboro};\n    `}\n`\n","import classnames from 'classnames'\nimport styled from 'styled-components'\n\nimport type { HTMLAttributes } from 'react'\n\nexport type FieldErrorProps = HTMLAttributes<HTMLParagraphElement> & {\n  isDisabled?: boolean | undefined\n}\nexport const FieldError = styled.p.attrs<FieldErrorProps, FieldErrorProps>(props => ({\n  className: classnames('Element-FieldError', props.className)\n}))`\n  color: ${p => p.theme.color.maximumRed};\n  display: ${p => (p.isDisabled ? 'none' : 'block')};\n  font-size: 13px;\n  font-style: italic;\n  line-height: 1.3846;\n  margin: 4px 0 0 0;\n`\n","import classnames from 'classnames'\nimport styled from 'styled-components'\n\nimport type { LabelHTMLAttributes } from 'react'\n\nexport type LabelProps = LabelHTMLAttributes<HTMLLabelElement> & {\n  disabled?: boolean | undefined\n  hasError?: boolean | undefined\n  isHidden?: boolean | undefined\n}\nexport const Label = styled.label.attrs<LabelProps, LabelProps>(props => ({\n  className: classnames('Element-Label', props.className)\n}))`\n  color: ${p =>\n    // eslint-disable-next-line no-nested-ternary\n    p.disabled ? p.theme.color.lightGray : p.hasError ? p.theme.color.maximumRed : p.theme.color.slateGray};\n  display: ${p => (p.isHidden ? 'none' : 'block')};\n  font-size: 13px;\n  line-height: 1.3846;\n  margin-bottom: 4px;\n`\n","import styled from 'styled-components'\n\nexport const Disk = styled.span<{\n  $color: string\n}>`\n  background-color: ${p => p.$color};\n  border-radius: 50%;\n`\n","import classnames from 'classnames'\nimport { type FunctionComponent, type HTMLAttributes, useMemo } from 'react'\nimport styled from 'styled-components'\n\nimport { Disk } from './Disk'\nimport { Accent, TagBullet } from '../../constants'\nimport { THEME } from '../../theme'\n\nimport type { IconProps } from '../../types'\n\nexport type TagProps = HTMLAttributes<HTMLSpanElement> & {\n  Icon?: FunctionComponent<IconProps> | undefined\n  accent?: Accent | undefined\n  bullet?: TagBullet | undefined\n  bulletColor?: string | undefined\n  isLight?: boolean | undefined\n}\nexport function Tag({\n  accent,\n  bullet,\n  bulletColor,\n  children,\n  className,\n  color,\n  Icon,\n  isLight = false,\n  ...nativeProps\n}: TagProps) {\n  const commonChildren = useMemo(() => {\n    const defaultColor = color || THEME.color.gunMetal\n\n    const controlledBulletColor =\n      bulletColor ||\n      (accent\n        ? {\n            [Accent.PRIMARY]: THEME.color.gunMetal,\n            [Accent.SECONDARY]: THEME.color.gunMetal,\n            [Accent.TERTIARY]: THEME.color.white\n          }[accent]\n        : defaultColor)\n\n    return (\n      <>\n        {Icon && <Icon size={1} />}\n        {bullet === TagBullet.DISK && <Disk $color={controlledBulletColor} />}\n\n        {children}\n      </>\n    )\n  }, [accent, bullet, bulletColor, color, children, Icon])\n\n  const commonProps = useMemo(\n    () => ({\n      $isLight: isLight,\n      children: commonChildren,\n      className: classnames('Element-Tag', className),\n      ...nativeProps\n    }),\n    [className, commonChildren, isLight, nativeProps]\n  )\n\n  switch (accent) {\n    case Accent.PRIMARY:\n      return <PrimaryTag {...commonProps} />\n\n    case Accent.SECONDARY:\n      return <SecondaryTag {...commonProps} />\n\n    case Accent.TERTIARY:\n      return <TertiaryTag {...commonProps} />\n\n    default:\n      return <Box $color={color} {...commonProps} />\n  }\n}\n\nconst Box = styled.span<{\n  $color?: string | undefined\n  $isLight: boolean\n}>`\n  align-items: center;\n  background-color: ${p => (p.$isLight ? p.theme.color.white : 'transparent')};\n  border-radius: 11px;\n  color: ${p => (p.$color ? p.$color : p.theme.color.gunMetal)};\n  display: inline-flex;\n  font-size: 13px;\n  line-height: 1.3846;\n  padding: 1px 8px 3px 8px;\n\n  /* Bullet components are a span */\n  > span {\n    height: 16px;\n    margin-right: 4px;\n    width: 16px;\n  }\n\n  /* SVG Icon components are wrapped within a <div /> */\n  > div {\n    margin-right: 4px;\n  }\n`\n\nexport const PrimaryTag = styled(Box)<{\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  color: ${p => p.theme.color.gunMetal};\n`\n\n// TODO Fix this color.\nexport const SecondaryTag = styled(Box)<{\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? '#f6d012' : '#f6d012')};\n  color: ${p => p.theme.color.gunMetal};\n`\n\nexport const TertiaryTag = styled(Box)<{\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.charcoal : p.theme.color.charcoal)};\n  color: ${p => p.theme.color.white};\n`\n","import classnames from 'classnames'\nimport { type ElementType, type SyntheticEvent, useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { AutoComplete as RsuiteAutoComplete } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Accent, Size } from '../constants'\nimport { Field } from '../elements/Field'\nimport { FieldError } from '../elements/FieldError'\nimport { IconButton } from '../elements/IconButton'\nimport { Label } from '../elements/Label'\nimport { useClickOutsideEffect } from '../hooks/useClickOutsideEffect'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useForceUpdate } from '../hooks/useForceUpdate'\nimport { useKey } from '../hooks/useKey'\nimport { Close, Search as SearchIcon } from '../icons'\nimport { THEME } from '../theme'\nimport { getRsuiteDataFromOptions } from '../utils/getRsuiteDataFromOptions'\nimport { getRsuiteValueFromOptionValue } from '../utils/getRsuiteValueFromOptionValue'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { CustomSearch } from '../libs/CustomSearch'\nimport type { Option, OptionAsRsuiteItemDataType, OptionValueType } from '../types'\nimport type { AutoCompleteProps as RsuiteAutoCompleteProps } from 'rsuite'\nimport type { ItemDataType } from 'rsuite/esm/@types/common'\nimport type { Promisable } from 'type-fest'\n\nexport type SearchProps<OptionValue extends OptionValueType = string> = Omit<\n  RsuiteAutoCompleteProps,\n  'as' | 'container' | 'data' | 'defaultValue' | 'id' | 'onChange' | 'open' | 'onSelect' | 'value'\n> & {\n  MenuItem?: ElementType | undefined\n  /** Used to pass something else than `window.document` as a base container to attach global events listeners. */\n  baseContainer?: Document | HTMLDivElement | null | undefined\n  customSearch?: CustomSearch<Option<OptionValue>> | undefined\n  /** Minimum search query length required to trigger custom search filtering. */\n  customSearchMinQueryLength?: number | undefined\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isSearchIconVisible?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: OptionValue | undefined) => Promisable<void>) | undefined\n  onQuery?: ((nextQuery: string | undefined) => Promisable<void>) | undefined\n  optionValueKey?: keyof OptionValue | undefined\n  options?: Option<OptionValue>[]\n  value?: OptionValue | undefined\n}\nexport function Search<OptionValue extends OptionValueType = string>({\n  baseContainer,\n  className,\n  customSearch = undefined,\n  customSearchMinQueryLength = 1,\n  error,\n  isErrorMessageHidden = false,\n  isLabelHidden,\n  isLight = false,\n  isSearchIconVisible = true,\n  label,\n  MenuItem,\n  onChange,\n  onQuery,\n  options = [],\n  optionValueKey,\n  style,\n  value,\n  ...originalProps\n}: SearchProps<OptionValue>) {\n  // eslint-disable-next-line no-null/no-null\n  const boxRef = useRef<HTMLDivElement | null>(null)\n  /** Instance of `CustomSearch` */\n  const customSearchRef = useRef(customSearch)\n\n  const queryRef = useRef<string | undefined>(undefined)\n\n  const data = useMemo(() => getRsuiteDataFromOptions(options, optionValueKey), [options, optionValueKey])\n\n  const [isOpen, setIsOpen] = useState(false)\n\n  const { forceUpdate } = useForceUpdate()\n\n  const controlledClassName = useMemo(() => classnames('Field-Search', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([value, originalProps.disabled, originalProps.name])\n\n  const rsuiteValue = useMemo(() => getRsuiteValueFromOptionValue(value, optionValueKey), [value, optionValueKey])\n  const [inputValue, setInputValue] = useState<string | undefined>(rsuiteValue)\n\n  // Only used when `customSearch` prop is set\n  const [controlledRsuiteData, setControlledRsuiteData] = useState<\n    OptionAsRsuiteItemDataType<OptionValue>[] | undefined\n  >(customSearch ? [] : undefined)\n\n  const close = useCallback(() => {\n    setIsOpen(false)\n  }, [])\n\n  const clean = useCallback(() => {\n    setInputValue('')\n    setIsOpen(false)\n  }, [])\n\n  const handleChange = useCallback(\n    async (nextQuery: OptionValue, event: SyntheticEvent) => {\n      if (!(typeof nextQuery === 'string')) {\n        return\n      }\n\n      if (customSearch && customSearchRef.current) {\n        const nextControlledRsuiteData =\n          nextQuery.trim().length >= customSearchMinQueryLength\n            ? getRsuiteDataFromOptions(customSearchRef.current.find(nextQuery), optionValueKey)\n            : []\n        setControlledRsuiteData(nextControlledRsuiteData)\n      }\n\n      queryRef.current = normalizeString(nextQuery)\n      if (event.type === 'change') {\n        setInputValue(nextQuery)\n        setIsOpen(Boolean(queryRef.current))\n      } else {\n        setIsOpen(false)\n      }\n\n      if (onChange && !queryRef.current) {\n        onChange(undefined)\n      }\n\n      if (onQuery) {\n        onQuery(queryRef.current)\n      }\n    },\n    [customSearch, onChange, onQuery, customSearchMinQueryLength, optionValueKey]\n  )\n  const handleSelect = useCallback(\n    (_, item: Option<OptionValue>) => {\n      if (onChange) {\n        onChange(item.optionValue)\n      }\n      setInputValue(item.label)\n    },\n    [onChange]\n  )\n\n  useFieldUndefineEffect(originalProps.disabled, onChange)\n\n  useClickOutsideEffect(boxRef, close, baseContainer)\n\n  useEffect(() => {\n    forceUpdate()\n  }, [forceUpdate])\n\n  return (\n    <Field className={controlledClassName} style={style}>\n      <Label\n        disabled={originalProps.disabled}\n        hasError={hasError}\n        htmlFor={originalProps.name}\n        isHidden={isLabelHidden}\n      >\n        {label}\n      </Label>\n\n      <Box ref={boxRef} isLight={isLight}>\n        {boxRef.current && (\n          <StyledAutoComplete\n            key={key}\n            $isLight={isLight}\n            container={boxRef.current}\n            // When we use a custom search, we use `controlledRsuiteData` to provide the matching options (data),\n            // when we don't, we don't need to control that and just pass the non-internally-controlled `rsuiteData`\n            data={controlledRsuiteData || data}\n            // When we use a custom search, we use `controlledRsuiteData` to provide the matching options (data),\n            // that's why we send this \"always true\" filter to disable Rsuite SelectPicker internal search filtering\n            filterBy={(customSearch ? () => true : undefined) as any}\n            id={originalProps.name}\n            onChange={handleChange}\n            onSelect={handleSelect}\n            open={isOpen}\n            renderMenuItem={(itemLabel, item: ItemDataType<OptionValue>) =>\n              MenuItem ? <MenuItem item={item.value} /> : itemLabel\n            }\n            value={inputValue}\n            {...originalProps}\n          />\n        )}\n        {inputValue && (\n          <>\n            <StyledCloseButton\n              accent={Accent.TERTIARY}\n              color={THEME.color.slateGray}\n              Icon={Close}\n              isSearchIconVisible={isSearchIconVisible}\n              onClick={clean}\n              size={Size.SMALL}\n            />\n            {isSearchIconVisible && <Separator>|</Separator>}\n          </>\n        )}\n        {isSearchIconVisible && <StyledIconSearch color={THEME.color.slateGray} size={20} />}\n      </Box>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Field>\n  )\n}\n\nconst StyledCloseButton = styled(IconButton)<{\n  isSearchIconVisible: boolean\n}>`\n  cursor: pointer;\n  height: 30px;\n  margin: 5px ${p => (p.isSearchIconVisible ? 0 : 5)}px 5px 5px;\n  padding: 8px;\n  width: 30px;\n`\n\nconst StyledIconSearch = styled(SearchIcon)`\n  margin: 10px 10px 10px 8px;\n`\n\nconst Separator = styled.div`\n  height: 40px;\n  font-weight: 300;\n  color: ${p => p.theme.color.lightGray};\n  padding-top: 3px;\n  font-size: 20.5px;\n`\n\nconst StyledAutoComplete = styled(RsuiteAutoComplete)<{\n  $isLight: boolean\n}>`\n  font-size: 13px;\n  flex-grow: 1;\n\n  .rs-input {\n    background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n    border-width: 0 0 1px;\n    border-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n\n    font-size: 13px;\n    width: 100%;\n    height: 40px;\n    padding: 11px 16px;\n\n    :focus {\n      outline: unset;\n      border-color: transparent;\n    }\n    :hover {\n      outline: unset;\n      border-color: transparent;\n    }\n  }\n`\n\nconst Box = styled.div<{\n  isLight: boolean\n}>`\n  background-color: ${p => (p.isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  position: relative;\n  width: 100%;\n  display: flex;\n\n  > .rs-picker-select {\n    > .rs-picker-toggle {\n      font-size: 13px;\n\n      > .rs-stack {\n        > .rs-stack-item {\n          > .rs-picker-toggle-placeholder {\n            font-size: 13px;\n          }\n        }\n      }\n    }\n  }\n`\n","import { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { DatePicker as RsuiteDatePicker } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { useForceUpdate } from '../../hooks/useForceUpdate'\nimport { customDayjs } from '../../utils/customDayjs'\nimport { getLocalizedDayjs } from '../../utils/getLocalizedDayjs'\nimport { getUtcizedDayjs } from '../../utils/getUtcizedDayjs'\nimport { stopMouseEventPropagation } from '../../utils/stopMouseEventPropagation'\nimport { RSUITE_CALENDAR_LOCALE } from '../DateRangePicker/constants'\nimport { getUtcDateTupleFromDayjs } from '../DateRangePicker/utils'\n\nimport type { DateTuple } from '../DateRangePicker/types'\nimport type { Promisable } from 'type-fest'\n\ntype CalendarPickerProps = {\n  isHistorical?: boolean | undefined\n  isOpen: boolean\n  /**\n   * @description\n   * Note that `nextUtcDateTuple` is ALREADY utized from the user pick.\n   */\n  onChange: (nextUtcDateTuple: DateTuple) => Promisable<void>\n  /**\n   * @description\n   * We expect a UTC Date here and NOT a utcized one.\n   */\n  value?: Date | undefined\n}\nexport function CalendarPicker({ isHistorical, isOpen, onChange, value }: CalendarPickerProps) {\n  const boxRef = useRef<HTMLDivElement>()\n\n  const { forceUpdate } = useForceUpdate()\n\n  const utcTodayAsDayjs = useMemo(() => customDayjs().utc().endOf('day'), [])\n  const controlledValue = useMemo(() => (value ? getLocalizedDayjs(value).toDate() : undefined), [value])\n  const shouldDisableDate = useMemo(\n    () => (date?: Date) => date && isHistorical ? getUtcizedDayjs(date).isAfter(utcTodayAsDayjs) : false,\n    [isHistorical, utcTodayAsDayjs]\n  )\n\n  const handleSelect = useCallback(\n    (nextLocalDate: Date) => {\n      // We utcize the date picked by the user\n      const nextUtcDateAsDayjs = getUtcizedDayjs(nextLocalDate)\n      const nextUtcDateTuple = getUtcDateTupleFromDayjs(nextUtcDateAsDayjs)\n\n      onChange(nextUtcDateTuple)\n    },\n    [onChange]\n  )\n\n  useEffect(() => {\n    // We wait for the <Box /> to render so that `boxRef` is defined\n    // and can be used as a container for <RsuiteDatePicker />\n    forceUpdate()\n  }, [forceUpdate])\n\n  return (\n    <Box ref={boxRef as any} onClick={stopMouseEventPropagation}>\n      {boxRef.current && (\n        <RsuiteDatePicker\n          container={boxRef.current}\n          format=\"yyyy-MM-dd\"\n          locale={RSUITE_CALENDAR_LOCALE}\n          oneTap\n          onSelect={handleSelect}\n          open={isOpen}\n          ranges={[]}\n          shouldDisableDate={shouldDisableDate}\n          // eslint-disable-next-line no-null/no-null\n          value={controlledValue ?? null}\n        />\n      )}\n    </Box>\n  )\n}\n\nexport const Box = styled.div`\n  height: 0;\n  position: relative;\n  user-select: none;\n\n  /*\n    This is a hack to hide .rs-picker-date > .rs-picker-toggle which must exist in DOM\n    since it's used as a ref by Rsuite to calculate .rs-picker-date-menu position\n  */\n  .rs-picker-date {\n    font-size: 0;\n    position: absolute;\n\n    .rs-picker-toggle {\n      border: 0 !important;\n      box-shadow: none;\n      padding: 0;\n\n      * {\n        display: none;\n      }\n    }\n  }\n\n  .rs-picker-date-menu {\n    box-shadow: inset 0px 0px 0px 1px ${p => p.theme.color.lightGray};\n    border-radius: 0;\n    margin-top: 2px;\n\n    .rs-picker-date-header,\n    .rs-calendar-header-time-toolbar,\n    .rs-picker-toolbar {\n      display: none;\n    }\n\n    .rs-calendar {\n      border: 0;\n      font-size: 13px;\n      height: auto !important;\n      line-height: 1.3846;\n      padding: 0;\n\n      > .rs-calendar-header {\n        border-bottom: solid 1px ${p => p.theme.color.lightGray};\n        padding: 4px 0;\n\n        > .rs-calendar-header-month-toolbar {\n          align-items: center;\n          color: ${p => p.theme.color.slateGray};\n          display: flex;\n          justify-content: space-between;\n\n          > .rs-calendar-header-backward {\n            color: ${p => p.theme.color.slateGray};\n          }\n\n          > .rs-calendar-header-title {\n            color: ${p => p.theme.color.slateGray};\n            font-size: 13px;\n            font-weight: 500;\n            padding: 5px 8px 6px;\n            text-transform: uppercase;\n\n            &.rs-calendar-header-error {\n              color: ${p => p.theme.color.slateGray};\n\n              &:hover {\n                color: ${p => p.theme.color.slateGray};\n              }\n            }\n          }\n\n          > .rs-calendar-header-forward {\n            color: ${p => p.theme.color.slateGray};\n          }\n        }\n      }\n\n      > .rs-calendar-body {\n        padding: 12px 8px 0;\n\n        .rs-calendar-table-cell {\n          padding: 0 0 4px 0;\n          width: 33px;\n\n          &.rs-calendar-table-cell-in-range:before {\n            background-color: ${p => p.theme.color.blueGray[25]};\n            height: 33px;\n            margin-top: 0;\n          }\n\n          > .rs-calendar-table-cell-content {\n            border-radius: 0 !important;\n            display: inline-flex;\n            height: 33px;\n            justify-content: center;\n            line-height: 1;\n            padding: 7px 0 0;\n            width: 33px;\n          }\n          &:hover .rs-calendar-table-cell-content {\n            background-color: ${p => p.theme.color.blueYonder[25]};\n            color: ${p => p.theme.color.blueYonder[100]};\n          }\n          &[role='columnheader'] .rs-calendar-table-cell-content,\n          &[role='columnheader']:hover .rs-calendar-table-cell-content {\n            background-color: transparent;\n            color: ${p => p.theme.color.slateGray};\n          }\n          &.rs-calendar-table-cell-disabled .rs-calendar-table-cell-content {\n            background-color: transparent;\n            color: ${p => p.theme.color.lightGray};\n          }\n          &.rs-calendar-table-cell-selected > .rs-calendar-table-cell-content {\n            background-color: ${p => p.theme.color.blueGray[100]};\n          }\n        }\n      }\n\n      > .rs-calendar-month-dropdown {\n        border: 0;\n        margin-top: 3px;\n\n        .rs-calendar-month-dropdown-year {\n          color: ${p => p.theme.color.slateGray};\n\n          &.rs-calendar-month-dropdown-year-active {\n            color: ${p => p.theme.color.blueYonder[100]};\n          }\n        }\n\n        .rs-calendar-month-dropdown-cell {\n          > .rs-calendar-month-dropdown-cell-content {\n            border-radius: 0 !important;\n            color: ${p => p.theme.color.gunMetal};\n            display: inline-flex;\n            height: 33px;\n            justify-content: center;\n            line-height: 1;\n            padding: 8px 0 0;\n            width: 33px;\n          }\n          &:hover > .rs-calendar-month-dropdown-cell-content {\n            background-color: ${p => p.theme.color.blueYonder[25]};\n            color: ${p => p.theme.color.blueYonder[100]};\n          }\n          &.rs-calendar-month-dropdown-cell-active > .rs-calendar-month-dropdown-cell-content {\n            background-color: ${p => p.theme.color.blueGray[100]};\n            color: ${p => p.theme.color.white};\n          }\n        }\n      }\n    }\n  }\n`\n","import {\n  forwardRef,\n  type KeyboardEvent,\n  useCallback,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  type FocusEvent,\n  type ForwardedRef,\n  type InputHTMLAttributes\n} from 'react'\nimport styled from 'styled-components'\n\nimport { usePreventWheelEvent } from '../../hooks/usePreventWheelEvent'\n\nimport type { Promisable } from 'type-fest'\n\nexport type NumberInputProps = Omit<\n  InputHTMLAttributes<HTMLInputElement>,\n  'defaultValue' | 'maxLength' | 'onInput' | 'pattern' | 'type'\n> & {\n  isLight: boolean\n  max?: number\n  min?: number\n  /** Called when the use press backspace key while the input is empty. */\n  onBack?: (() => Promisable<void>) | undefined\n  /** Called when the input value reaches the size property. */\n  onFilled?: (() => Promisable<void>) | undefined\n  onFormatError: (hasNextFormatError: boolean) => Promisable<void>\n  onInput?: ((nextValue: string) => Promisable<void>) | undefined\n  /** Called when the right arrow is pressed while the cursor is positionned at the input end. */\n  onNext?: (() => Promisable<void>) | undefined\n  /** Called when the left arrow is pressed while the cursor is positionned at the input start. */\n  onPrevious?: (() => Promisable<void>) | undefined\n  size: number\n}\nfunction NumberInputWithRef(\n  {\n    isLight,\n    max,\n    min,\n    onBack,\n    onBlur,\n    onFilled,\n    onFocus,\n    onFormatError,\n    onInput,\n    onNext,\n    onPrevious,\n    size,\n    value,\n    ...nativeProps\n  }: NumberInputProps,\n  ref: ForwardedRef<HTMLInputElement>\n) {\n  // eslint-disable-next-line no-null/no-null\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const placeholder = useMemo(() => '-'.repeat(size), [size])\n\n  useImperativeHandle(ref, () => inputRef.current as HTMLInputElement)\n\n  const preventWheelEvent = usePreventWheelEvent(inputRef)\n\n  const handleBlur = useCallback(\n    (event: FocusEvent<HTMLInputElement>) => {\n      event.target.removeEventListener('wheel', preventWheelEvent)\n\n      if (onBlur) {\n        onBlur(event)\n      }\n    },\n    [onBlur, preventWheelEvent]\n  )\n\n  const handleFocus = useCallback(\n    (event: FocusEvent<HTMLInputElement>) => {\n      if (!inputRef.current) {\n        return\n      }\n\n      event.target.addEventListener('wheel', preventWheelEvent)\n\n      inputRef.current.select()\n\n      if (onFocus) {\n        onFocus(event)\n      }\n    },\n    [onFocus, preventWheelEvent]\n  )\n\n  const handleInput = useCallback(() => {\n    if (!inputRef.current) {\n      return\n    }\n\n    onFormatError(false)\n\n    if (onInput) {\n      onInput(inputRef.current.value)\n    }\n    if (inputRef.current.value.length !== size) {\n      return\n    }\n\n    const valueAsNumber = Number(inputRef.current.value)\n    if (Number.isNaN(valueAsNumber) || valueAsNumber < min || valueAsNumber > max) {\n      onFormatError(true)\n\n      return\n    }\n\n    if (onFilled && inputRef.current.value.length === size) {\n      onFilled()\n    }\n  }, [max, min, onFilled, onFormatError, onInput, size])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLInputElement>) => {\n      if (!inputRef.current) {\n        return\n      }\n\n      if (onBack && event.key === 'Backspace' && !inputRef.current.value.length) {\n        event.preventDefault()\n\n        onBack()\n      }\n    },\n    [onBack]\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLInputElement>) => {\n      if (!inputRef.current) {\n        return\n      }\n\n      if (\n        onPrevious &&\n        event.key === 'ArrowLeft' &&\n        inputRef.current.selectionStart === 0 &&\n        // We don't want to call that function when the user is selecting the input text\n        inputRef.current.selectionEnd === inputRef.current.selectionStart\n      ) {\n        event.preventDefault()\n\n        onPrevious()\n\n        return\n      }\n\n      if (\n        onNext &&\n        event.key === 'ArrowRight' &&\n        inputRef.current.selectionStart === inputRef.current.value.length &&\n        // We don't want to call that function when the user is selecting the input text\n        inputRef.current.selectionEnd === inputRef.current.selectionStart\n      ) {\n        event.preventDefault()\n\n        onNext()\n\n        return\n      }\n\n      // TODO Find a better solution that this dirty hack handling \"onRefilled\" case.\n      if (\n        onNext &&\n        inputRef.current.value.length === size &&\n        inputRef.current.selectionStart === inputRef.current.value.length &&\n        // We don't want to call that function when the user is selecting the input text\n        inputRef.current.selectionEnd === inputRef.current.selectionStart\n      ) {\n        event.preventDefault()\n\n        onNext()\n      }\n    },\n    [onNext, onPrevious, size]\n  )\n\n  return (\n    <StyledNumberInput\n      key={String(value)}\n      ref={inputRef}\n      $isLight={isLight}\n      $size={size}\n      defaultValue={value}\n      maxLength={size}\n      onBlur={handleBlur}\n      onFocus={handleFocus}\n      onInput={handleInput}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      pattern=\"\\d*\"\n      placeholder={placeholder}\n      type=\"text\"\n      {...nativeProps}\n    />\n  )\n}\n\nexport const NumberInput = forwardRef(NumberInputWithRef)\n\nconst StyledNumberInput = styled.input<{\n  $isLight: boolean\n  $size: number\n}>`\n  background-color: transparent;\n  border: 0;\n  color: ${p => p.theme.color.gunMetal};\n  font-size: inherit;\n  outline: none;\n  padding: 0;\n  text-align: center;\n  /* 1 digit = 8px */\n  width: ${p => p.$size * 8}px;\n\n  ::placeholder {\n    color: ${p => (p.$isLight ? p.theme.color.slateGray : p.theme.color.slateGray)};\n  }\n`\n","import { forwardRef, useCallback, useImperativeHandle, useMemo, useRef, useState } from 'react'\nimport styled from 'styled-components'\n\nimport { NumberInput } from './NumberInput'\nimport { formatNumberAsDoubleDigit, isHtmlElement } from './utils'\nimport { Calendar } from '../../icons'\n\nimport type { NumberInputProps } from './NumberInput'\nimport type { DateTuple, DateInputRef } from './types'\nimport type { ForwardedRef } from 'react'\nimport type { Promisable } from 'type-fest'\n\nexport type DateInputProps = Pick<NumberInputProps, 'onBack' | 'onPrevious' | 'onNext'> & {\n  baseContainer: Document | HTMLDivElement | undefined\n  // TODO Check why TS thinks there is no `disabled` prop in `NumberInputProps`.\n  disabled: boolean\n  isCompact: boolean\n  isEndDate?: boolean | undefined\n  isForcedFocused: boolean\n  isLight: boolean\n  /**\n   * Is this date input included in the `<DateRangePicker />`?\n   *\n   * @description\n   * Impact the input labels.\n   */\n  isRange?: boolean | undefined\n  isStartDate?: boolean | undefined\n  /** Called each time any date input is changed to a new valid value. */\n  onChange: (nextDateTuple: DateTuple, isFilled: boolean) => Promisable<void>\n  onClick: () => Promisable<void>\n  /** Called each time any date input receive a keyboard-input change whether the value is valid or not. */\n  onInput: () => Promisable<void>\n  value?: DateTuple | undefined\n}\nfunction DateInputWithRef(\n  {\n    baseContainer,\n    disabled = false,\n    isCompact,\n    isEndDate = false,\n    isForcedFocused,\n    isLight,\n    isRange = false,\n    isStartDate = false,\n    onBack,\n    onChange,\n    onClick,\n    onInput,\n    onNext,\n    onPrevious,\n    value\n  }: DateInputProps,\n  ref: ForwardedRef<DateInputRef>\n) {\n  /* eslint-disable no-null/no-null */\n  const boxRef = useRef<HTMLDivElement>(null)\n  const dayInputRef = useRef<HTMLInputElement>(null)\n  const monthInputRef = useRef<HTMLInputElement>(null)\n  const yearInputRef = useRef<HTMLInputElement>(null)\n  /* eslint-enable no-null/no-null */\n\n  const lastValueBeforeFocusRef = useRef(value)\n\n  const [hasFormatError, setHasFormatError] = useState(false)\n  const [hasValidationError, setHasValidationError] = useState(false)\n  const [isFocused, setIsFocused] = useState(false)\n\n  const baseDocument = useMemo(\n    () => (isHtmlElement(baseContainer) ? baseContainer.ownerDocument : window.document),\n    [baseContainer]\n  )\n  const controlledValue = useMemo(() => {\n    if (!isFocused) {\n      lastValueBeforeFocusRef.current = value\n    }\n\n    return lastValueBeforeFocusRef.current\n  }, [isFocused, value])\n\n  const key = JSON.stringify(lastValueBeforeFocusRef.current)\n\n  useImperativeHandle<DateInputRef, DateInputRef>(ref, () => ({\n    box: boxRef.current,\n    contains: boxRef.current ? boxRef.current.contains.bind(boxRef.current) : () => false,\n    focus: (isInLastInputOfTheGroup = false) => {\n      if (isInLastInputOfTheGroup) {\n        yearInputRef.current?.focus()\n      } else {\n        dayInputRef.current?.focus()\n      }\n    },\n    getValueAsPartialDateTuple: () => [\n      yearInputRef.current?.value.length ? yearInputRef.current.value : undefined,\n      monthInputRef.current?.value.length ? monthInputRef.current.value : undefined,\n      dayInputRef.current?.value.length ? dayInputRef.current.value : undefined\n    ]\n  }))\n\n  const handleBlur = useCallback(() => {\n    setIsFocused(false)\n  }, [])\n\n  const handleFocus = useCallback(() => {\n    setIsFocused(true)\n  }, [])\n\n  const handleFormatError = useCallback((hasNextFormatError: boolean) => {\n    setHasFormatError(hasNextFormatError)\n  }, [])\n\n  const submit = useCallback(() => {\n    if (!yearInputRef.current || !monthInputRef.current || !dayInputRef.current) {\n      return\n    }\n\n    setHasValidationError(false)\n\n    const isFilled = baseDocument.activeElement === yearInputRef.current\n\n    switch (baseDocument.activeElement) {\n      case dayInputRef.current:\n        monthInputRef.current.focus()\n        break\n\n      case monthInputRef.current:\n        yearInputRef.current.focus()\n        break\n\n      default:\n        break\n    }\n\n    if (\n      !yearInputRef.current.value.length ||\n      !monthInputRef.current.value.length ||\n      !dayInputRef.current.value.length\n    ) {\n      if (\n        (monthInputRef.current.value.length && !dayInputRef.current.value.length) ||\n        (yearInputRef.current.value.length &&\n          (!dayInputRef.current.value.length || !monthInputRef.current.value.length))\n      ) {\n        setHasValidationError(true)\n      }\n\n      return\n    }\n\n    const nextDateTuple: DateTuple = [\n      String(yearInputRef.current.value),\n      formatNumberAsDoubleDigit(monthInputRef.current.value),\n      formatNumberAsDoubleDigit(dayInputRef.current.value)\n    ]\n\n    onChange(nextDateTuple, isFilled)\n  }, [baseDocument, onChange])\n\n  return (\n    <Box\n      ref={boxRef}\n      $hasError={hasFormatError || hasValidationError}\n      $isCompact={isCompact}\n      $isDisabled={disabled}\n      $isFocused={isForcedFocused || isFocused}\n      $isLight={isLight}\n    >\n      <div>\n        {isRange && isStartDate && <span>Du </span>}\n        {isRange && isEndDate && <span>Au </span>}\n        <NumberInput\n          key={`${key}-day`}\n          ref={dayInputRef}\n          aria-label={`Jour${isRange && isStartDate ? ' de dbut' : ''}${isRange && isEndDate ? ' de fin' : ''}`}\n          disabled={disabled}\n          isLight={isLight}\n          max={31}\n          min={1}\n          onBack={onBack}\n          onBlur={handleBlur}\n          onClick={onClick}\n          onFilled={submit}\n          onFocus={handleFocus}\n          onFormatError={handleFormatError}\n          onInput={onInput}\n          onNext={() => monthInputRef.current?.focus()}\n          onPrevious={onPrevious}\n          size={2}\n          value={controlledValue && controlledValue[2]}\n        />\n        /\n        <NumberInput\n          key={`${key}-month`}\n          ref={monthInputRef}\n          aria-label={`Mois${isRange && isStartDate ? ' de dbut' : ''}${isRange && isEndDate ? ' de fin' : ''}`}\n          disabled={disabled}\n          isLight={isLight}\n          max={12}\n          min={1}\n          onBack={() => dayInputRef.current?.focus()}\n          onBlur={handleBlur}\n          onClick={onClick}\n          onFilled={submit}\n          onFocus={handleFocus}\n          onFormatError={handleFormatError}\n          onInput={onInput}\n          onNext={() => yearInputRef.current?.focus()}\n          onPrevious={() => dayInputRef.current?.focus()}\n          size={2}\n          value={controlledValue && controlledValue[1]}\n        />\n        /\n        <NumberInput\n          key={`${key}-year`}\n          ref={yearInputRef}\n          aria-label={`Anne${isRange && isStartDate ? ' de dbut' : ''}${isRange && isEndDate ? ' de fin' : ''}`}\n          disabled={disabled}\n          isLight={isLight}\n          onBack={() => monthInputRef.current?.focus()}\n          onBlur={handleBlur}\n          onClick={onClick}\n          onFilled={submit}\n          onFocus={handleFocus}\n          onFormatError={handleFormatError}\n          onInput={onInput}\n          onNext={onNext}\n          onPrevious={() => monthInputRef.current?.focus()}\n          size={4}\n          value={controlledValue && controlledValue[0]}\n        />\n      </div>\n\n      {!isCompact && <Calendar />}\n    </Box>\n  )\n}\n\nexport const DateInput = forwardRef(DateInputWithRef)\n\nconst Box = styled.div<{\n  $hasError: boolean\n  $isCompact: boolean\n  $isDisabled: boolean\n  $isFocused: boolean\n  $isLight: boolean\n}>`\n  align-items: center;\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  box-shadow: ${p =>\n    p.$hasError || p.$isFocused\n      ? `inset 0px 0px 0px 1px ${p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100]}`\n      : 'none'};\n  color: ${p => (p.$isFocused ? p.theme.color.blueGray[100] : p.theme.color.slateGray)};\n  display: inline-flex;\n  font-size: inherit;\n  justify-content: space-between;\n  padding: ${p => (p.$isCompact ? '4.5px 8px 7px' : '3px 8px 5px')};\n  user-select: none;\n\n  :hover {\n    box-shadow: ${p =>\n      `inset 0px 0px 0px 1px ${\n        // eslint-disable-next-line no-nested-ternary\n        p.$isDisabled\n          ? p.theme.color.cultured\n          : p.$isFocused\n          ? p.theme.color.blueGray[100]\n          : p.theme.color.blueYonder[100]\n      }`};\n    color: ${p => (p.$isFocused ? p.theme.color.blueGray[100] : p.theme.color.blueYonder[100])};\n  }\n\n  > div:nth-child(2) {\n    margin: 2px 0 0 16px;\n  }\n`\n","import { useCallback, useEffect, useMemo, useState } from 'react'\nimport styled from 'styled-components'\n\nimport { getRangedTimeOptions } from './utils'\nimport { stopMouseEventPropagation } from '../../utils/stopMouseEventPropagation'\n\nimport type { TimeTuple } from './types'\nimport type { Promisable } from 'type-fest'\n\ntype RangedTimePickerProps = {\n  filter: RegExp\n  minutesRange: number\n  onChange: (nextTimeTuple: TimeTuple) => Promisable<void>\n}\nexport function RangedTimePicker({ filter, minutesRange, onChange }: RangedTimePickerProps) {\n  const [selectedOptionIndex, setSelectedOptionIndex] = useState(0)\n\n  const rangedTimeOptions = useMemo(() => getRangedTimeOptions(minutesRange), [minutesRange])\n  const filteredRangedTimeOptions = useMemo(\n    () => rangedTimeOptions.filter(({ label }) => filter.test(label)),\n    [filter, rangedTimeOptions]\n  )\n\n  const spannedLabels = useMemo(\n    () =>\n      filteredRangedTimeOptions.map(({ label }) => {\n        const [hours, minutes] = label.split(':')\n\n        return (\n          <>\n            {' '}\n            <span>{hours}</span>:<span>{minutes}</span>\n          </>\n        )\n      }),\n    [filteredRangedTimeOptions]\n  )\n\n  const handleBoxKeyDown = useCallback(\n    (event: globalThis.KeyboardEvent) => {\n      if (event.key === 'ArrowDown') {\n        event.preventDefault()\n\n        const nextSelectedOptionIndex =\n          selectedOptionIndex < filteredRangedTimeOptions.length - 1 ? selectedOptionIndex + 1 : 0\n\n        setSelectedOptionIndex(nextSelectedOptionIndex)\n\n        window.document.querySelectorAll('.js-ranged-time-picker-option')[nextSelectedOptionIndex]?.scrollIntoView()\n      }\n\n      if (event.key === 'ArrowUp') {\n        event.preventDefault()\n\n        const nextSelectedOptionIndex =\n          selectedOptionIndex > 0 ? selectedOptionIndex - 1 : filteredRangedTimeOptions.length - 1\n\n        setSelectedOptionIndex(nextSelectedOptionIndex)\n\n        window.document.querySelectorAll('.js-ranged-time-picker-option')[nextSelectedOptionIndex]?.scrollIntoView()\n      }\n\n      if (['Enter', 'Space', 'Tab'].includes(event.key)) {\n        const selectedRangedTimeOption = filteredRangedTimeOptions[selectedOptionIndex]\n        if (!selectedRangedTimeOption) {\n          return\n        }\n\n        onChange(selectedRangedTimeOption.value)\n      }\n    },\n    [filteredRangedTimeOptions, selectedOptionIndex, onChange]\n  )\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleBoxKeyDown, {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      once: true\n    })\n\n    return () => {\n      window.removeEventListener('keydown', handleBoxKeyDown)\n    }\n  }, [handleBoxKeyDown])\n\n  useEffect(() => {\n    setSelectedOptionIndex(0)\n  }, [filteredRangedTimeOptions])\n\n  if (!filteredRangedTimeOptions.length) {\n    return <></>\n  }\n\n  return (\n    <Box onClick={stopMouseEventPropagation} role=\"listbox\">\n      {filteredRangedTimeOptions.map(({ label, value }, index) => (\n        <Option\n          key={label}\n          aria-selected={false}\n          className=\"js-ranged-time-picker-option\"\n          isSelected={index === selectedOptionIndex}\n          onClick={() => onChange(value)}\n          role=\"option\"\n          tabIndex={-1}\n        >\n          {spannedLabels[index]}\n        </Option>\n      ))}\n    </Box>\n  )\n}\n\nconst Box = styled.div`\n  background-color: ${p => p.theme.color.white};\n  box-shadow: inset 0px 0px 0px 1px ${p => p.theme.color.lightGray};\n  display: flex;\n  flex-direction: column;\n  left: 0;\n  max-height: 160px;\n  overflow: auto;\n  position: absolute;\n  /* Non-WebKit Firefox Compatibility */\n  scrollbar-color: ${p => p.theme.color.lightGray};\n  scrollbar-width: thin;\n  top: 32px;\n  width: 100%;\n  z-index: 9999;\n\n  ::-webkit-scrollbar {\n    -webkit-appearance: none;\n  }\n  ::-webkit-scrollbar:vertical {\n    width: 5px;\n  }\n  ::-webkit-scrollbar-thumb {\n    border: 0;\n    background-color: ${p => p.theme.color.lightGray};\n  }\n  ::-webkit-scrollbar-track {\n    background-color: ${p => p.theme.color.gainsboro};\n  }\n`\n\nconst Option = styled.div<{\n  isSelected: boolean\n}>`\n  background-color: ${p => (p.isSelected ? p.theme.color.blueGray[100] : 'transparent')};\n  color: ${p => (p.isSelected ? p.theme.color.white : p.theme.color.gunMetal)};\n  cursor: pointer;\n  line-height: 1;\n  padding: 5px 0 7px 6.5px;\n\n  :hover {\n    background-color: ${p => (p.isSelected ? p.theme.color.blueGray[100] : p.theme.color.blueYonder[25])};\n  }\n\n  > span {\n    display: inline-flex;\n    justify-content: center;\n    width: 16px;\n  }\n`\n","import { isEqual } from 'lodash'\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react'\nimport styled from 'styled-components'\n\nimport { NumberInput } from './NumberInput'\nimport { RangedTimePicker } from './RangedTimePicker'\nimport { isHtmlElement } from './utils'\nimport { useClickOutsideEffect } from '../../hooks/useClickOutsideEffect'\nimport { usePrevious } from '../../hooks/usePrevious'\nimport { Clock } from '../../icons'\n\nimport type { NumberInputProps } from './NumberInput'\nimport type { TimeInputRef, TimeTuple } from './types'\nimport type { ForwardedRef } from 'react'\nimport type { Promisable } from 'type-fest'\n\nexport type TimeInputProps = Pick<NumberInputProps, 'onBack' | 'onPrevious' | 'onNext'> & {\n  baseContainer?: Document | HTMLDivElement | undefined\n  // TODO Check why TS thinks there is no `disabled` prop in `NumberInputProps`.\n  disabled: boolean\n  isCompact: boolean\n  isEndDate?: boolean | undefined\n  isLight: boolean\n  isStartDate?: boolean | undefined\n  minutesRange?: number | undefined\n  /** Called each time any time input is changed to a new valid value. */\n  onChange: (nextTimeTuple: TimeTuple) => Promisable<void>\n  onFocus?: (() => Promisable<void>) | undefined\n  /** Called each time any time input receive a keyboard-input change whether the value is valid or not. */\n  onInput: () => Promisable<void>\n  onNext?: (() => Promisable<void>) | undefined\n  onPrevious?: (() => Promisable<void>) | undefined\n  value?: TimeTuple | undefined\n}\nfunction TimeInputWithRef(\n  {\n    baseContainer,\n    disabled = false,\n    isCompact,\n    isEndDate = false,\n    isLight,\n    isStartDate = false,\n    minutesRange = 15,\n    onBack,\n    onChange,\n    onFocus,\n    onInput,\n    onNext,\n    onPrevious,\n    value\n  }: TimeInputProps,\n  ref: ForwardedRef<TimeInputRef>\n) {\n  /* eslint-disable no-null/no-null */\n  const boxRef = useRef<HTMLDivElement>(null)\n  const hourInputRef = useRef<HTMLInputElement>(null)\n  const minuteInputRef = useRef<HTMLInputElement>(null)\n  /* eslint-enable no-null/no-null */\n\n  const [controlledValue, setControlledValue] = useState(value)\n  const [hasFormatError, setHasFormatError] = useState(false)\n  const [hasValidationError, setHasValidationError] = useState(false)\n  const [isFocused, setIsFocused] = useState(false)\n  const [isTimePickerOpen, setIsTimePickerOpen] = useState(false)\n  const [timePickerFilter, setTimePickerFilter] = useState<RegExp>(/.*/)\n\n  const previousValue = usePrevious(value)\n\n  const baseDocument = useMemo(\n    () => (isHtmlElement(baseContainer) ? baseContainer.ownerDocument : window.document),\n    [baseContainer]\n  )\n\n  useImperativeHandle<TimeInputRef, TimeInputRef>(ref, () => ({\n    box: boxRef.current,\n    focus: (isInLastInputOfTheGroup = false) => {\n      if (isInLastInputOfTheGroup) {\n        minuteInputRef.current?.focus()\n      } else {\n        hourInputRef.current?.focus()\n      }\n    },\n    getValueAsPartialTimeTuple: () => [\n      hourInputRef.current?.value.length ? hourInputRef.current.value : undefined,\n      minuteInputRef.current?.value.length ? minuteInputRef.current.value : undefined\n    ]\n  }))\n\n  const closeRangedTimePicker = useCallback(() => {\n    setIsTimePickerOpen(false)\n  }, [])\n\n  const handleBack = useCallback(() => {\n    if (!onBack) {\n      return\n    }\n\n    closeRangedTimePicker()\n\n    onBack()\n  }, [closeRangedTimePicker, onBack])\n\n  const handleBlur = useCallback(() => {\n    setIsFocused(false)\n  }, [])\n\n  const handleFocus = useCallback(() => {\n    setIsFocused(true)\n\n    if (onFocus) {\n      onFocus()\n    }\n  }, [onFocus])\n\n  const handleFormatError = useCallback((hasNextFormatError: boolean) => {\n    setHasFormatError(hasNextFormatError)\n  }, [])\n\n  const handleHourInput = useCallback(\n    (nextValue: string) => {\n      // eslint-disable-next-line no-nested-ternary\n      const nextRangedTimePickerFilter = nextValue.length ? new RegExp(`^${nextValue}`) : /.*/\n\n      setTimePickerFilter(nextRangedTimePickerFilter)\n\n      onInput()\n    },\n    [onInput]\n  )\n\n  const handleTimePickerChange = useCallback(\n    (nextTimeTuple: TimeTuple) => {\n      closeRangedTimePicker()\n\n      setControlledValue(nextTimeTuple)\n\n      onChange(nextTimeTuple)\n    },\n    [closeRangedTimePicker, onChange]\n  )\n\n  const openRangedTimePicker = useCallback(() => {\n    setIsTimePickerOpen(true)\n  }, [])\n\n  const submit = useCallback(() => {\n    if (!hourInputRef.current || !minuteInputRef.current) {\n      return\n    }\n\n    setHasValidationError(false)\n\n    if (baseDocument.activeElement === hourInputRef.current) {\n      minuteInputRef.current.focus()\n    }\n\n    if (!hourInputRef.current.value.length || !minuteInputRef.current.value.length) {\n      if (minuteInputRef.current.value.length && !hourInputRef.current.value.length) {\n        setHasValidationError(true)\n      }\n\n      return\n    }\n\n    closeRangedTimePicker()\n\n    const nextTimeTuple: TimeTuple = [hourInputRef.current.value, minuteInputRef.current.value]\n    onChange(nextTimeTuple)\n  }, [baseDocument, closeRangedTimePicker, onChange])\n\n  useClickOutsideEffect(boxRef, closeRangedTimePicker, baseContainer)\n\n  useEffect(() => {\n    if (isEqual(value, previousValue) || isFocused) {\n      return\n    }\n\n    setControlledValue(value)\n  }, [isFocused, previousValue, value])\n\n  return (\n    <Box\n      ref={boxRef}\n      $hasError={hasFormatError || hasValidationError}\n      $isCompact={isCompact}\n      $isDisabled={disabled}\n      $isFocused={isFocused}\n      $isLight={isLight}\n    >\n      <InputGroup>\n        <div>\n          <NumberInput\n            ref={hourInputRef}\n            aria-label={`Heure${isStartDate ? ' de dbut' : ''}${isEndDate ? ' de fin' : ''}`}\n            disabled={disabled}\n            isLight={isLight}\n            max={23}\n            min={0}\n            onBack={handleBack}\n            onBlur={handleBlur}\n            onClick={openRangedTimePicker}\n            onFilled={submit}\n            onFocus={handleFocus}\n            onFormatError={handleFormatError}\n            onInput={handleHourInput}\n            onNext={() => minuteInputRef.current?.focus()}\n            onPrevious={onPrevious}\n            size={2}\n            value={controlledValue && controlledValue[0]}\n          />\n          :\n          <NumberInput\n            ref={minuteInputRef}\n            aria-label={`Minute${isStartDate ? ' de dbut' : ''}${isEndDate ? ' de fin' : ''}`}\n            disabled={disabled}\n            isLight={isLight}\n            max={59}\n            min={0}\n            onBack={() => hourInputRef.current?.focus()}\n            onBlur={handleBlur}\n            onClick={openRangedTimePicker}\n            onFilled={submit}\n            onFocus={handleFocus}\n            onFormatError={handleFormatError}\n            onInput={onInput}\n            onNext={onNext}\n            onPrevious={() => hourInputRef.current?.focus()}\n            size={2}\n            value={controlledValue && controlledValue[1]}\n          />\n        </div>\n\n        {!isCompact && <Clock />}\n      </InputGroup>\n\n      {isTimePickerOpen && (\n        <RangedTimePicker filter={timePickerFilter} minutesRange={minutesRange} onChange={handleTimePickerChange} />\n      )}\n    </Box>\n  )\n}\n\nexport const TimeInput = forwardRef(TimeInputWithRef)\n\nconst Box = styled.div<{\n  $hasError: boolean\n  $isCompact: boolean\n  $isDisabled: boolean\n  $isFocused: boolean\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  box-shadow: ${p =>\n    p.$hasError || p.$isFocused\n      ? `inset 0px 0px 0px 1px ${p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100]}`\n      : 'none'};\n  color: ${p => (p.$isFocused ? p.theme.color.blueGray[100] : p.theme.color.slateGray)};\n  display: inline-block;\n  font-size: inherit;\n  padding: ${p => (p.$isCompact ? '4.5px 8px 7px' : '3px 8px 5px')};\n  position: relative;\n  user-select: none;\n\n  :hover {\n    box-shadow: ${p =>\n      `inset 0px 0px 0px 1px ${\n        // eslint-disable-next-line no-nested-ternary\n        p.$isDisabled\n          ? p.theme.color.cultured\n          : p.$isFocused\n          ? p.theme.color.blueGray[100]\n          : p.theme.color.blueYonder[100]\n      }`};\n    color: ${p => (p.$isFocused ? p.theme.color.blueGray[100] : p.theme.color.blueYonder[100])};\n  }\n`\n\nconst InputGroup = styled.div`\n  align-items: center;\n  display: flex;\n  justify-content: space-between;\n\n  > div:nth-child(2) {\n    margin: 2px 0 0 16px;\n  }\n`\n","/**\n * The time and date text input values are used as tuples (i.e.: `[\"2021\", \"12\", \"31\"]`, `[\"23\", \"59\"]`)\n * in order to avoid over-converting datetimes between UTC and local time zones.\n *\n * Once we receive a new tuple (because the user entered/picked a new value has been changed), we treat it as a UTC one,\n * whether it's a date or a time.\n *\n * In short, ALL INTERNAL DATETIME-RELATED VALUES ARE ALWAYS TREATED AS WE WERE RUNNING IN A UTC TIME ZONE.\n *\n * The only exception is the `<CalendarPicker />` which returns a local date which must be \"utcized\",\n * meaning that it must be treated as if the date was picked in a UTC timezone\n * despite the local time zone marker (i.e.: `+01:00`) as well as the DST (Daylight Saving Time).\n *\n * In this case, if the user picked December 31st, 2021 on the calendar,\n * it MUST BE interpreted as `2021-12-31T00:00:00.000Z` and NOT `2021-12-31T00:00:00.000HH:MM`.\n */\n\nimport classnames from 'classnames'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport styled, { css } from 'styled-components'\n\nimport { CalendarPicker } from './CalendarPicker'\nimport { FieldError } from '../../elements/FieldError'\nimport { Fieldset } from '../../elements/Fieldset'\nimport { useClickOutsideEffect } from '../../hooks/useClickOutsideEffect'\nimport { useFieldUndefineEffect } from '../../hooks/useFieldUndefineEffect'\nimport { useForceUpdate } from '../../hooks/useForceUpdate'\nimport { usePrevious } from '../../hooks/usePrevious'\nimport { customDayjs } from '../../utils/customDayjs'\nimport { normalizeString } from '../../utils/normalizeString'\nimport { DateInput } from '../DateRangePicker/DateInput'\nimport { TimeInput } from '../DateRangePicker/TimeInput'\nimport {\n  getDayjsFromUtcDateAndTimeTuple,\n  getUtcDateFromDateAndTimeTuple,\n  getUtcDateTupleFromDayjs,\n  getUtcTimeTupleFromDayjs\n} from '../DateRangePicker/utils'\n\nimport type { DateInputRef, DateTuple, TimeInputRef, TimeTuple } from '../DateRangePicker/types'\nimport type { HTMLAttributes } from 'react'\nimport type { Promisable } from 'type-fest'\n\n/**\n * @description\n * This type should not be exposed in the distributed library. It's only exported to be reused in <FormikDatePicker />.\n *\n * @private\n */\nexport interface DatePickerProps\n  extends Omit<HTMLAttributes<HTMLFieldSetElement>, 'defaultValue' | 'onChange' | 'placeholder'> {\n  /** Used to pass something else than `window.document` as a base container to attach global events listeners. */\n  baseContainer?: Document | HTMLDivElement | null | undefined\n  defaultValue?: Date | string | undefined\n  disabled?: boolean | undefined\n  error?: string | undefined\n  isCompact?: boolean | undefined\n  /** Set the default time to the end (instead of start) of the day when picking/entering a date. */\n  isEndDate?: boolean | undefined\n  isErrorMessageHidden?: boolean | undefined\n  /** Only allow past dates until today. */\n  isHistorical?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isStringDate?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  /**\n   * Range of minutes used to generate the time picker list.\n   *\n   * @example\n   * `15` would produce a list with `..., 10:45, 11:00, 11:15, ...`.\n   */\n  minutesRange?: number | undefined\n  /**\n   * Called each time the date range picker is changed to a new valid value.\n   *\n   * @param nextUtcDateRange - A utcized date to be used as is to interact with the API.\n   */\n  onChange?:\n    | ((nextUtcDate: Date | undefined) => Promisable<void>)\n    | ((nextUtcDate: string | undefined) => Promisable<void>)\n    | undefined\n  withTime?: boolean | undefined\n}\nexport interface DatePickerWithDateDateProps extends DatePickerProps {\n  isStringDate?: false | undefined\n  onChange?: (nextUtcDate: Date | undefined) => Promisable<void> | undefined\n}\nexport interface DatePickerWithStringDateProps extends DatePickerProps {\n  isStringDate: true\n  onChange?: (nextUtcDate: string | undefined) => Promisable<void> | undefined\n}\n\n// TODO We should make this component both form- & a11y-compliant with a `name` and proper (aria-)labels.\nexport function DatePicker(props: DatePickerWithDateDateProps): JSX.Element\nexport function DatePicker(props: DatePickerWithStringDateProps): JSX.Element\nexport function DatePicker({\n  baseContainer,\n  className,\n  defaultValue,\n  disabled = false,\n  error,\n  isCompact = false,\n  isEndDate = false,\n  isErrorMessageHidden = false,\n  isHistorical = false,\n  isLabelHidden = false,\n  isLight = false,\n  isStringDate = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  minutesRange = 15,\n  onChange,\n  style,\n  withTime = false,\n  ...nativeProps\n}: DatePickerProps) {\n  /* eslint-disable no-null/no-null */\n  const boxRef = useRef<HTMLDivElement>(null)\n  const dateInputRef = useRef<DateInputRef>(null)\n  const timeInputRef = useRef<TimeInputRef>(null)\n  /* eslint-enable no-null/no-null */\n\n  const hasMountedRef = useRef(false)\n  const selectedUtcDateAsDayjsRef = useRef(defaultValue ? customDayjs(defaultValue) : undefined)\n  const selectedUtcDateTupleRef = useRef(getUtcDateTupleFromDayjs(selectedUtcDateAsDayjsRef.current))\n  const selectedUtcTimeTupleRef = useRef(getUtcTimeTupleFromDayjs(selectedUtcDateAsDayjsRef.current))\n\n  const [isRangeCalendarPickerOpen, setIsRangeCalendarPickerOpen] = useState(false)\n\n  const controlledClassName = useMemo(() => classnames('Field-DatePicker', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const defaultTimeTuple: TimeTuple = useMemo(() => (isEndDate ? ['23', '59'] : ['00', '00']), [isEndDate])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const previousDefaultValue = usePrevious(defaultValue)\n\n  const { forceUpdate } = useForceUpdate()\n\n  const calendarPickerDefaultValue = useMemo(\n    () =>\n      selectedUtcDateTupleRef.current\n        ? getUtcDateFromDateAndTimeTuple(selectedUtcDateTupleRef.current, defaultTimeTuple)\n        : undefined,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [selectedUtcDateTupleRef.current]\n  )\n\n  const callOnChange = useCallback(() => {\n    if (!onChange || !selectedUtcDateAsDayjsRef.current) {\n      return\n    }\n\n    const nextDateAsDayjs = selectedUtcDateAsDayjsRef.current\n\n    if (isStringDate) {\n      ;(onChange as (nextUtcDate: string) => Promisable<void>)(nextDateAsDayjs.toISOString())\n    } else {\n      ;(onChange as (nextUtcDate: Date) => Promisable<void>)(nextDateAsDayjs.toDate())\n    }\n  }, [isStringDate, onChange])\n\n  const callOnChangeUndefinedIfInputsAreEmpty = useCallback(() => {\n    if (!dateInputRef.current || !onChange) {\n      return\n    }\n\n    const [year, month, day] = dateInputRef.current.getValueAsPartialDateTuple()\n\n    if (!withTime && !year && !month && !day) {\n      onChange(undefined)\n\n      return\n    }\n\n    if (!timeInputRef.current) {\n      return\n    }\n\n    const [hour, minute] = timeInputRef.current.getValueAsPartialTimeTuple()\n    if (!year && !month && !day && !hour && !minute) {\n      onChange(undefined)\n    }\n  }, [onChange, withTime])\n\n  const closeCalendarPicker = useCallback(() => {\n    setIsRangeCalendarPickerOpen(false)\n  }, [])\n\n  const handleDateInputNext = useCallback(() => {\n    if (!withTime || !timeInputRef.current) {\n      return\n    }\n\n    timeInputRef.current.focus()\n  }, [withTime])\n\n  const handleDateInputChange = useCallback(\n    (nextUtcDateTuple: DateTuple, isFilled: boolean) => {\n      selectedUtcDateTupleRef.current = nextUtcDateTuple\n\n      // If there is NO time input OR there is a time input WHILE a time is selected,\n      if (!withTime || (withTime && selectedUtcTimeTupleRef.current)) {\n        // we must update the selected datetime and call `onChange()`\n        const timeTuple =\n          withTime && selectedUtcTimeTupleRef.current ? selectedUtcTimeTupleRef.current : defaultTimeTuple\n\n        selectedUtcDateAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(nextUtcDateTuple, timeTuple, isEndDate)\n\n        callOnChange()\n      }\n\n      if (isFilled) {\n        handleDateInputNext()\n      }\n    },\n    [callOnChange, defaultTimeTuple, handleDateInputNext, isEndDate, withTime]\n  )\n\n  const handleCalendarPickerChange = useCallback(\n    (nextUtcizedDateTuple: DateTuple) => {\n      // If there is NO time input,\n      if (!withTime) {\n        // we update the selected datetime\n        selectedUtcDateAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(\n          nextUtcizedDateTuple,\n          // with a time set to the start (or end) of the day\n          defaultTimeTuple,\n          isEndDate\n        )\n      }\n\n      // If there is a time input AND a time is selected,\n      else if (selectedUtcTimeTupleRef.current) {\n        // we update the selected datetime\n        selectedUtcDateAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(\n          nextUtcizedDateTuple,\n          selectedUtcTimeTupleRef.current,\n          isEndDate\n        )\n      }\n\n      selectedUtcDateTupleRef.current = nextUtcizedDateTuple\n      selectedUtcTimeTupleRef.current = getUtcTimeTupleFromDayjs(selectedUtcDateAsDayjsRef.current)\n\n      closeCalendarPicker()\n      forceUpdate()\n\n      callOnChange()\n\n      if (withTime && timeInputRef.current) {\n        timeInputRef.current.focus()\n      }\n    },\n    [callOnChange, closeCalendarPicker, defaultTimeTuple, forceUpdate, isEndDate, withTime]\n  )\n\n  const handleDisable = useCallback(() => {\n    selectedUtcDateTupleRef.current = undefined\n    selectedUtcTimeTupleRef.current = undefined\n\n    forceUpdate()\n  }, [forceUpdate])\n\n  const handleTimeInputChange = useCallback(\n    (nextTimeTuple: TimeTuple) => {\n      // If a date is selected\n      if (selectedUtcDateTupleRef.current) {\n        // we update the selected datetime\n        const nextDateAsDayjs = getDayjsFromUtcDateAndTimeTuple(selectedUtcDateTupleRef.current, nextTimeTuple)\n\n        selectedUtcDateAsDayjsRef.current = nextDateAsDayjs\n      }\n\n      selectedUtcTimeTupleRef.current = nextTimeTuple\n\n      callOnChange()\n    },\n    [callOnChange]\n  )\n\n  const openCalendarPicker = useCallback(() => {\n    setIsRangeCalendarPickerOpen(true)\n  }, [])\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && disabled, onChange, handleDisable)\n\n  useClickOutsideEffect(boxRef, closeCalendarPicker, baseContainer)\n\n  useEffect(() => {\n    if (!hasMountedRef.current) {\n      hasMountedRef.current = true\n\n      return\n    }\n\n    if (\n      (defaultValue instanceof Date &&\n        previousDefaultValue instanceof Date &&\n        defaultValue.toISOString() === previousDefaultValue.toISOString()) ||\n      defaultValue === previousDefaultValue\n    ) {\n      return\n    }\n\n    selectedUtcDateAsDayjsRef.current = defaultValue ? customDayjs(defaultValue) : undefined\n    selectedUtcDateTupleRef.current = getUtcDateTupleFromDayjs(selectedUtcDateAsDayjsRef.current)\n    selectedUtcTimeTupleRef.current = getUtcTimeTupleFromDayjs(selectedUtcDateAsDayjsRef.current)\n\n    forceUpdate()\n  }, [defaultValue, forceUpdate, previousDefaultValue])\n\n  return (\n    <Fieldset\n      className={controlledClassName}\n      disabled={disabled}\n      hasError={hasError}\n      isLegendHidden={isLabelHidden}\n      legend={label}\n      style={style}\n      {...nativeProps}\n    >\n      <Box ref={boxRef} $hasError={hasError} $isDisabled={disabled}>\n        <Field>\n          <DateInput\n            ref={dateInputRef}\n            baseContainer={baseContainer || undefined}\n            disabled={disabled}\n            isCompact={isCompact}\n            isEndDate={isEndDate}\n            isForcedFocused={isRangeCalendarPickerOpen}\n            isLight={isLight}\n            onChange={handleDateInputChange}\n            onClick={openCalendarPicker}\n            onInput={callOnChangeUndefinedIfInputsAreEmpty}\n            onNext={handleDateInputNext}\n            value={selectedUtcDateTupleRef.current}\n          />\n        </Field>\n\n        {withTime && (\n          <Field $isTimeField>\n            <TimeInput\n              ref={timeInputRef}\n              baseContainer={baseContainer || undefined}\n              disabled={disabled}\n              isCompact={isCompact}\n              isLight={isLight}\n              minutesRange={minutesRange}\n              onBack={() => dateInputRef.current?.focus(true)}\n              onChange={handleTimeInputChange}\n              onFocus={closeCalendarPicker}\n              onInput={callOnChangeUndefinedIfInputsAreEmpty}\n              onPrevious={() => dateInputRef.current?.focus(true)}\n              value={selectedUtcTimeTupleRef.current}\n            />\n          </Field>\n        )}\n      </Box>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n\n      <CalendarPicker\n        isHistorical={isHistorical}\n        isOpen={isRangeCalendarPickerOpen}\n        onChange={handleCalendarPickerChange}\n        value={calendarPickerDefaultValue}\n      />\n    </Fieldset>\n  )\n}\n\nconst Box = styled.div<{\n  $hasError: boolean\n  $isDisabled: boolean\n}>`\n  * {\n    font-weight: 500;\n    line-height: 1;\n  }\n\n  color: ${p => p.theme.color.gunMetal};\n  display: inline-flex;\n  font-size: 13px;\n  outline: ${p => (p.$hasError ? `1px solid ${p.theme.color.maximumRed}` : 0)};\n  position: relative;\n\n  ${p =>\n    p.$isDisabled &&\n    css`\n      * {\n        background-color: ${p.theme.color.cultured} !important;\n        color: ${p.theme.color.lightGray} !important;\n        cursor: not-allowed;\n      }\n    `}\n`\n\nconst Field = styled.span<{\n  $isTimeField?: boolean\n}>`\n  font-size: inherit;\n  margin-left: ${p => (p.$isTimeField ? '2px' : 0)};\n`\n","import { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { DateRangePicker as RsuiteDateRangePicker } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { RSUITE_CALENDAR_LOCALE } from './constants'\nimport { getDateTupleFromUtcDate } from './utils'\nimport { useForceUpdate } from '../../hooks/useForceUpdate'\nimport { customDayjs } from '../../utils/customDayjs'\nimport { getUtcizedDayjs } from '../../utils/getUtcizedDayjs'\nimport { sortDates } from '../../utils/sortDates'\nimport { stopMouseEventPropagation } from '../../utils/stopMouseEventPropagation'\n\nimport type { DateTupleRange } from './types'\nimport type { DateRange } from '../../types'\nimport type { Promisable } from 'type-fest'\n\ntype RangeCalendarPickerProps = {\n  /**\n   * @description\n   * We expect a UTC Date range here and NOT a utcized one.\n   *\n   * The order between the start and end date doesn't matter since it's sorted internally.\n   */\n  defaultValue?: DateRange | undefined\n  isHistorical?: boolean | undefined\n  isOpen: boolean\n  /**\n   * @description\n   * Note that `nextUtcdDateTupleRange` is ALREADY utized from the user pick.\n   */\n  onChange: (nextUtcDateTupleRange: DateTupleRange) => Promisable<void>\n}\nexport function RangeCalendarPicker({ defaultValue, isHistorical, isOpen, onChange }: RangeCalendarPickerProps) {\n  const boxRef = useRef<HTMLDivElement>()\n  // It's called \"first\" and \"second\" because the calendar can also be picked from right to left,\n  // that's why we sort these first and second dates before calling `onChange()`\n  // in order to distinguish the start date from the end date\n  const selectedFirstUtcDate = useRef<Date>()\n  const selectedSecondUtcDate = useRef<Date>()\n\n  const { forceUpdate } = useForceUpdate()\n\n  const controlledValue = useMemo(\n    () => (defaultValue ? (sortDates(defaultValue) as DateRange) : undefined),\n    [defaultValue]\n  )\n  const utcTodayAsDayjs = useMemo(() => customDayjs().utc().endOf('day'), [])\n  const shouldDisableDate = useMemo(\n    () => (date: Date) => isHistorical ? getUtcizedDayjs(date).isAfter(utcTodayAsDayjs) : false,\n    [isHistorical, utcTodayAsDayjs]\n  )\n\n  const handleSelect = useCallback(\n    (nextLocalDate: Date) => {\n      // We utcize the date picked by the user\n      const nextUtcDate = getUtcizedDayjs(nextLocalDate).toDate()\n\n      if (!selectedFirstUtcDate.current || selectedSecondUtcDate.current) {\n        selectedFirstUtcDate.current = nextUtcDate\n        selectedSecondUtcDate.current = undefined\n\n        return\n      }\n\n      const sortedDateRange = sortDates([selectedFirstUtcDate.current, nextUtcDate]) as DateRange\n      const [startDate, endDate] = sortedDateRange\n      const startDateTuple = getDateTupleFromUtcDate(startDate)\n      const endDateTuple = getDateTupleFromUtcDate(endDate)\n      const nextUtcDateTupleRange = [startDateTuple, endDateTuple] as DateTupleRange\n\n      selectedSecondUtcDate.current = nextUtcDate\n\n      onChange(nextUtcDateTupleRange)\n    },\n    [onChange]\n  )\n\n  useEffect(() => {\n    // We wait for the <Box /> to render so that `boxRef` is defined\n    // and can be used as a container for <RsuiteDateRangePicker />\n    forceUpdate()\n  }, [forceUpdate])\n\n  return (\n    <Box ref={boxRef as any} onClick={stopMouseEventPropagation}>\n      {boxRef.current && (\n        <RsuiteDateRangePicker\n          container={boxRef.current}\n          format=\"yyyy-MM-dd\"\n          locale={RSUITE_CALENDAR_LOCALE}\n          onSelect={handleSelect}\n          open={isOpen}\n          ranges={[]}\n          shouldDisableDate={shouldDisableDate}\n          // `defaultValue` seems to be immediatly cancelled so we come down to using a controlled `value`\n          // eslint-disable-next-line no-null/no-null\n          value={controlledValue ?? null}\n        />\n      )}\n    </Box>\n  )\n}\n\nconst Box = styled.div`\n  height: 0;\n  position: relative;\n  user-select: none;\n\n  /*\n    This is a hack to hide .rs-picker-daterange > .rs-picker-toggle which must exist in DOM\n    since it's used as a ref by Rsuite to calculate .rs-picker-daterange-menu position\n  */\n  .rs-picker-daterange {\n    font-size: 0;\n    position: absolute;\n\n    .rs-picker-toggle {\n      border: 0 !important;\n      padding: 0;\n      box-shadow: none;\n\n      * {\n        display: none;\n      }\n    }\n  }\n\n  .rs-picker-daterange-menu {\n    box-shadow: inset 0px 0px 0px 1px ${p => p.theme.color.lightGray};\n    border-radius: 0;\n    margin-top: 2px;\n    width: 495px;\n\n    .rs-picker-daterange-header,\n    .rs-calendar-header-time-toolbar,\n    .rs-picker-toolbar {\n      display: none;\n    }\n\n    .rs-picker-daterange-calendar-group {\n      height: auto;\n\n      > .rs-calendar {\n        font-size: 13px;\n        height: auto !important;\n        line-height: 1.3846;\n        padding: 0;\n\n        &:first-child {\n          border-right: solid 1px ${p => p.theme.color.lightGray};\n        }\n\n        > .rs-calendar-header {\n          border-bottom: solid 1px ${p => p.theme.color.lightGray};\n          padding: 8px;\n\n          > .rs-calendar-header-month-toolbar {\n            align-items: center;\n            color: ${p => p.theme.color.slateGray};\n            display: flex;\n            justify-content: space-between;\n\n            > .rs-calendar-header-backward {\n              color: ${p => p.theme.color.slateGray};\n            }\n\n            > .rs-calendar-header-title {\n              color: ${p => p.theme.color.slateGray};\n              font-size: 13px;\n              font-weight: 500;\n              padding: 5px 8px 6px;\n              text-transform: uppercase;\n\n              &.rs-calendar-header-error {\n                color: ${p => p.theme.color.slateGray};\n\n                &:hover {\n                  color: ${p => p.theme.color.slateGray};\n                }\n              }\n            }\n\n            > .rs-calendar-header-forward {\n              color: ${p => p.theme.color.slateGray};\n            }\n          }\n        }\n\n        > .rs-calendar-body {\n          padding: 12px 8px 0;\n\n          .rs-calendar-table-cell {\n            padding: 0 0 4px 0;\n            width: 33px;\n\n            &.rs-calendar-table-cell-in-range:before {\n              background-color: ${p => p.theme.color.blueGray[25]};\n              height: 33px;\n              margin-top: 0;\n            }\n\n            > .rs-calendar-table-cell-content {\n              border-radius: 0 !important;\n              display: inline-flex;\n              height: 33px;\n              justify-content: center;\n              line-height: 1;\n              padding: 7px 0 0;\n              width: 33px;\n            }\n            &:hover .rs-calendar-table-cell-content {\n              background-color: ${p => p.theme.color.blueYonder[25]};\n              color: ${p => p.theme.color.blueYonder[100]};\n            }\n            &[role='columnheader'] .rs-calendar-table-cell-content,\n            &[role='columnheader']:hover .rs-calendar-table-cell-content {\n              background-color: transparent;\n              color: ${p => p.theme.color.slateGray};\n            }\n            &.rs-calendar-table-cell-disabled .rs-calendar-table-cell-content {\n              background-color: transparent;\n              color: ${p => p.theme.color.lightGray};\n            }\n            &.rs-calendar-table-cell-selected > .rs-calendar-table-cell-content {\n              background-color: ${p => p.theme.color.blueGray[100]};\n            }\n          }\n        }\n\n        > .rs-calendar-month-dropdown {\n          border: 0;\n          margin-top: 3px;\n\n          .rs-calendar-month-dropdown-year {\n            color: ${p => p.theme.color.slateGray};\n\n            &.rs-calendar-month-dropdown-year-active {\n              color: ${p => p.theme.color.blueYonder[100]};\n            }\n          }\n\n          .rs-calendar-month-dropdown-cell {\n            > .rs-calendar-month-dropdown-cell-content {\n              border-radius: 0 !important;\n              color: ${p => p.theme.color.gunMetal};\n              display: inline-flex;\n              height: 33px;\n              justify-content: center;\n              line-height: 1;\n              padding: 8px 0 0;\n              width: 33px;\n            }\n            &:hover > .rs-calendar-month-dropdown-cell-content {\n              background-color: ${p => p.theme.color.blueYonder[25]};\n              color: ${p => p.theme.color.blueYonder[100]};\n            }\n            &.rs-calendar-month-dropdown-cell-active > .rs-calendar-month-dropdown-cell-content {\n              background-color: ${p => p.theme.color.blueGray[100]};\n              color: ${p => p.theme.color.white};\n            }\n          }\n        }\n      }\n    }\n  }\n`\n","/**\n * The time and date text input values are used as tuples (i.e.: `[\"2021\", \"12\", \"31\"]`, `[\"23\", \"59\"]`)\n * in order to avoid over-converting datetimes between UTC and local time zones.\n *\n * Once we receive a new tuple (because the user entered/picked a new value has been changed), we treat it as a UTC one,\n * whether it's a date or a time.\n *\n * In short, ALL INTERNAL DATETIME-RELATED VALUES ARE ALWAYS TREATED AS WE WERE RUNNING IN A UTC TIME ZONE.\n *\n * The only exception is the `<RangeCalendarPicker />` which returns a local date range which must be \"utcized\",\n * meaning that it must be treated as of the date range was picked in a UTC timezone\n * despite the local time zone marker (i.e.: `+01:00`) as well as the DST (Daylight Saving Time).\n *\n * In this case, if the user picked December 31st, 2021 as a start date on the calendar,\n * it MUST BE interpreted as `2021-12-31T00:00:00.000Z` and NOT `2021-12-31T00:00:00.000HH:MM`.\n * If the user picked December 31st, 2021 as an end date on the same calendar,\n * it MUST BE interpreted as `2021-12-31T23:59:59.000Z`\n * (we return `.000Z` rather than `.999Z` because the backend does not handle milliseconds as expected).\n */\n\nimport classnames from 'classnames'\nimport { isEqual } from 'lodash'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport styled, { css } from 'styled-components'\n\nimport { DateInput } from './DateInput'\nimport { RangeCalendarPicker } from './RangeCalendarPicker'\nimport { TimeInput } from './TimeInput'\nimport {\n  type DateInputRef,\n  DateRangePosition,\n  type DateTuple,\n  type DateTupleRange,\n  type TimeInputRef,\n  type TimeTuple\n} from './types'\nimport {\n  getDayjsFromUtcDateAndTimeTuple,\n  getUtcDateFromDateAndTimeTuple,\n  getUtcDateTupleFromDayjs,\n  getUtcTimeTupleFromDayjs\n} from './utils'\nimport { FieldError } from '../../elements/FieldError'\nimport { Fieldset } from '../../elements/Fieldset'\nimport { useClickOutsideEffect } from '../../hooks/useClickOutsideEffect'\nimport { useFieldUndefineEffect } from '../../hooks/useFieldUndefineEffect'\nimport { useForceUpdate } from '../../hooks/useForceUpdate'\nimport { usePrevious } from '../../hooks/usePrevious'\nimport { customDayjs } from '../../utils/customDayjs'\nimport { normalizeString } from '../../utils/normalizeString'\n\nimport type { DateAsStringRange, DateRange } from '../../types'\nimport type { HTMLAttributes } from 'react'\nimport type { Promisable } from 'type-fest'\n\n/**\n * @description\n * This type should not be exposed in the distributed library.\n * It's only exported to be reused in <FormikDateRangePicker />.\n *\n * @private\n */\nexport interface DateRangePickerProps\n  extends Omit<HTMLAttributes<HTMLFieldSetElement>, 'defaultValue' | 'onChange' | 'placeholder'> {\n  /** Used to pass something else than `window.document` as a base container to attach global events listeners. */\n  baseContainer?: Document | HTMLDivElement | null | undefined\n  defaultValue?: DateRange | DateAsStringRange | undefined\n  disabled?: boolean | undefined\n  error?: string | undefined\n  isCompact?: boolean | undefined\n  isErrorMessageHidden?: boolean | undefined\n  /** Only allow past dates until today. */\n  isHistorical?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isStringDate?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  /**\n   * Range of minutes used to generate the time picker list.\n   *\n   * @example\n   * `15` would produce a list with `..., 10:45, 11:00, 11:15, ...`.\n   */\n  minutesRange?: number\n  /**\n   * Called each time the date range picker is changed to a new valid value.\n   *\n   * @param nextUtcDateRange - A utcized date to be used as is to interact with the API.\n   */\n  onChange?:\n    | ((nextUtcDateRange: DateRange | undefined) => Promisable<void>)\n    | ((nextUtcDateRange: DateAsStringRange | undefined) => Promisable<void>)\n  withTime?: boolean\n}\nexport interface DateRangePickerWithDateDateProps extends DateRangePickerProps {\n  isStringDate?: false\n  onChange?: (nextUtcDateRange: DateRange | undefined) => Promisable<void>\n}\nexport interface DateRangePickerWithStringDateProps extends DateRangePickerProps {\n  isStringDate: true\n  onChange?: (nextUtcDateRange: DateAsStringRange | undefined) => Promisable<void>\n}\n\n// TODO We should make this component both form- & a11y-compliant with a `name` and proper (aria-)labels.\nexport function DateRangePicker(props: DateRangePickerWithDateDateProps): JSX.Element\nexport function DateRangePicker(props: DateRangePickerWithStringDateProps): JSX.Element\nexport function DateRangePicker({\n  baseContainer,\n  className,\n  defaultValue,\n  disabled = false,\n  error,\n  isCompact = false,\n  isErrorMessageHidden = false,\n  isHistorical = false,\n  isLabelHidden = false,\n  isLight = false,\n  isStringDate = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  minutesRange = 15,\n  onChange,\n  style,\n  withTime = false,\n  ...nativeProps\n}: DateRangePickerProps) {\n  /* eslint-disable no-null/no-null */\n  const startDateInputRef = useRef<DateInputRef>(null)\n  const startTimeInputRef = useRef<TimeInputRef>(null)\n  const endDateInputRef = useRef<DateInputRef>(null)\n  const endTimeInputRef = useRef<TimeInputRef>(null)\n  /* eslint-enable no-null/no-null */\n\n  const hasMountedRef = useRef(false)\n\n  const selectedStartDateTimeAsDayjsRef = useRef(defaultValue ? customDayjs(defaultValue[0]) : undefined)\n  const selectedStartDateTupleRef = useRef(getUtcDateTupleFromDayjs(selectedStartDateTimeAsDayjsRef.current))\n  const selectedStartTimeTupleRef = useRef(getUtcTimeTupleFromDayjs(selectedStartDateTimeAsDayjsRef.current))\n\n  const selectedEndDateTimeAsDayjsRef = useRef(defaultValue ? customDayjs(defaultValue[1]) : undefined)\n  const selectedEndDateTupleRef = useRef(getUtcDateTupleFromDayjs(selectedEndDateTimeAsDayjsRef.current))\n  const selectedEndTimeTupleRef = useRef(getUtcTimeTupleFromDayjs(selectedEndDateTimeAsDayjsRef.current))\n\n  const [isRangeCalendarPickerOpen, setIsRangeCalendarPickerOpen] = useState(false)\n\n  const controlledClassName = useMemo(() => classnames('Field-DateRangePicker', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const previousDefaultValue = usePrevious(defaultValue)\n\n  const { forceUpdate } = useForceUpdate()\n\n  const rangeCalendarPickerDefaultValue: DateRange | undefined = useMemo(\n    () =>\n      selectedStartDateTupleRef.current && selectedEndDateTupleRef.current\n        ? [\n            getUtcDateFromDateAndTimeTuple(selectedStartDateTupleRef.current, ['00', '00']),\n            getUtcDateFromDateAndTimeTuple(selectedEndDateTupleRef.current, ['00', '00'], true)\n          ]\n        : undefined,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [selectedEndDateTupleRef.current, selectedStartDateTupleRef.current]\n  )\n\n  const callOnChange = useCallback(() => {\n    if (!onChange || !selectedStartDateTimeAsDayjsRef.current || !selectedEndDateTimeAsDayjsRef.current) {\n      return\n    }\n\n    if (isStringDate) {\n      const startUtcDateAsString = selectedStartDateTimeAsDayjsRef.current.utc().toISOString()\n      const endUtcDateAsString = selectedEndDateTimeAsDayjsRef.current.utc().toISOString()\n\n      const nextUtcDateAsStringRange: DateAsStringRange = [startUtcDateAsString, endUtcDateAsString]\n\n      ;(onChange as (nextUtcDateRange: DateAsStringRange) => Promisable<void>)(nextUtcDateAsStringRange)\n\n      return\n    }\n\n    const startUtcDate = selectedStartDateTimeAsDayjsRef.current.toDate()\n    const endUtcDate = selectedEndDateTimeAsDayjsRef.current.toDate()\n\n    const nextDateRange: DateRange = [startUtcDate, endUtcDate]\n\n    ;(onChange as (nextUtcDateRange: DateRange) => Promisable<void>)(nextDateRange)\n  }, [isStringDate, onChange])\n\n  const callOnChangeUndefinedIfInputsAreEmpty = useCallback(() => {\n    if (!startDateInputRef.current || !endDateInputRef.current || !onChange) {\n      return\n    }\n\n    const [startYear, startMonth, startDay] = startDateInputRef.current.getValueAsPartialDateTuple()\n    const [endYear, endMonth, endDay] = endDateInputRef.current.getValueAsPartialDateTuple()\n\n    if (!withTime && !startYear && !startMonth && !startDay && !endYear && !endMonth && !endDay) {\n      onChange(undefined)\n\n      return\n    }\n\n    if (!startTimeInputRef.current || !endTimeInputRef.current) {\n      return\n    }\n\n    const [startHour, startMinute] = startTimeInputRef.current.getValueAsPartialTimeTuple()\n    const [endHour, endMinute] = endTimeInputRef.current.getValueAsPartialTimeTuple()\n    if (\n      !startYear &&\n      !startMonth &&\n      !startDay &&\n      !startHour &&\n      !startMinute &&\n      !endYear &&\n      !endMonth &&\n      !endDay &&\n      !endHour &&\n      !endMinute\n    ) {\n      onChange(undefined)\n    }\n  }, [onChange, withTime])\n\n  const closeRangeCalendarPicker = useCallback(() => {\n    setIsRangeCalendarPickerOpen(false)\n  }, [])\n\n  const handleDisable = useCallback(() => {\n    selectedStartDateTupleRef.current = undefined\n    selectedStartTimeTupleRef.current = undefined\n    selectedEndDateTupleRef.current = undefined\n    selectedEndTimeTupleRef.current = undefined\n\n    forceUpdate()\n  }, [forceUpdate])\n\n  const handleEndDateInputNext = useCallback(() => {\n    if (!withTime || !endTimeInputRef.current) {\n      return\n    }\n\n    endTimeInputRef.current.focus()\n  }, [withTime])\n\n  const handleEndDateInputPrevious = useCallback(() => {\n    if (!startDateInputRef.current) {\n      return\n    }\n\n    if (withTime && startTimeInputRef.current) {\n      startTimeInputRef.current.focus(true)\n\n      return\n    }\n\n    startDateInputRef.current.focus(true)\n  }, [withTime])\n\n  const handleStartDateInputNext = useCallback(() => {\n    if (!endDateInputRef.current) {\n      return\n    }\n\n    if (withTime && startTimeInputRef.current) {\n      startTimeInputRef.current.focus()\n\n      return\n    }\n\n    endDateInputRef.current.focus()\n  }, [withTime])\n\n  const handleDateInputChange = useCallback(\n    (position: DateRangePosition, nextDateTuple: DateTuple, isFilled: boolean) => {\n      if (position === DateRangePosition.START) {\n        selectedStartDateTupleRef.current = nextDateTuple\n\n        // If there is NO time input OR there is a time input WHILE a start time is selected,\n        if (!withTime || (withTime && selectedStartTimeTupleRef.current)) {\n          // we update the selected start datetime\n          const startUtcTimeTuple: TimeTuple =\n            withTime && selectedStartTimeTupleRef.current ? selectedStartTimeTupleRef.current : ['00', '00']\n          const nextStartDateAsDayjs = getDayjsFromUtcDateAndTimeTuple(nextDateTuple, startUtcTimeTuple)\n\n          selectedStartDateTimeAsDayjsRef.current = nextStartDateAsDayjs\n\n          callOnChange()\n        }\n\n        if (isFilled) {\n          handleStartDateInputNext()\n        }\n      } else {\n        selectedEndDateTupleRef.current = nextDateTuple\n\n        // If there is NO time input OR there is a time input WHILE a start time is selected,\n        if (!withTime || (withTime && selectedEndTimeTupleRef.current)) {\n          // we update the selected end datetime\n          const endTimeTuple = (withTime ? selectedEndTimeTupleRef.current : ['23', '59']) as TimeTuple\n          const nextEndDateAsDayjs = getDayjsFromUtcDateAndTimeTuple(nextDateTuple, endTimeTuple, true)\n\n          selectedEndDateTimeAsDayjsRef.current = nextEndDateAsDayjs\n\n          callOnChange()\n        }\n\n        if (isFilled) {\n          handleEndDateInputNext()\n        }\n      }\n    },\n    [callOnChange, handleEndDateInputNext, handleStartDateInputNext, withTime]\n  )\n\n  const handleRangeCalendarPickerChange = useCallback(\n    (nextUtcDateTupleRange: DateTupleRange) => {\n      const [nextStartUtcDateTuple, nextEndUtcDateTuple] = nextUtcDateTupleRange\n\n      // If there is NO time input,\n      if (!withTime) {\n        // we have to fix the start datetime at the beginning of the day\n        selectedStartDateTimeAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(nextStartUtcDateTuple, ['00', '00'])\n        // and the end datetime at the end of the day\n        selectedEndDateTimeAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(nextEndUtcDateTuple, ['23', '59'], true)\n      }\n\n      // If there is a time input,\n      else {\n        // AND there is BOTH a selected start time and a selected end time,\n        if (selectedStartTimeTupleRef.current && selectedEndTimeTupleRef.current) {\n          // we update the selected start datetime\n          selectedStartDateTimeAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(\n            nextStartUtcDateTuple,\n            selectedStartTimeTupleRef.current\n          )\n\n          // we update the selected start datetime\n          selectedEndDateTimeAsDayjsRef.current = getDayjsFromUtcDateAndTimeTuple(\n            nextEndUtcDateTuple,\n            selectedEndTimeTupleRef.current,\n            true\n          )\n        }\n\n        startTimeInputRef.current?.focus()\n      }\n\n      selectedStartDateTupleRef.current = nextStartUtcDateTuple\n      selectedStartTimeTupleRef.current = getUtcTimeTupleFromDayjs(selectedStartDateTimeAsDayjsRef.current)\n      selectedEndDateTupleRef.current = nextEndUtcDateTuple\n      selectedEndTimeTupleRef.current = getUtcTimeTupleFromDayjs(selectedEndDateTimeAsDayjsRef.current)\n\n      closeRangeCalendarPicker()\n\n      callOnChange()\n    },\n    [callOnChange, closeRangeCalendarPicker, withTime]\n  )\n\n  const handleTimeInputChange = useCallback(\n    (position: DateRangePosition, nextTimeTuple: TimeTuple) => {\n      if (!endDateInputRef.current) {\n        return\n      }\n\n      if (position === DateRangePosition.START) {\n        // If a start date is selected\n        if (selectedStartDateTupleRef.current) {\n          // we update the selected start datetime and submit it\n          const nextStartDateAsDayjs = getDayjsFromUtcDateAndTimeTuple(selectedStartDateTupleRef.current, nextTimeTuple)\n\n          selectedStartDateTimeAsDayjsRef.current = nextStartDateAsDayjs\n        }\n\n        selectedStartTimeTupleRef.current = nextTimeTuple\n      } else {\n        // If an end date is selected\n        if (selectedEndDateTupleRef.current) {\n          // we update the selected end datetime and submit it\n          const nextEndDateAsDayjs = getDayjsFromUtcDateAndTimeTuple(\n            selectedEndDateTupleRef.current,\n            nextTimeTuple,\n            true\n          )\n\n          selectedEndDateTimeAsDayjsRef.current = nextEndDateAsDayjs\n        }\n\n        selectedEndTimeTupleRef.current = nextTimeTuple\n      }\n\n      callOnChange()\n    },\n    [callOnChange]\n  )\n\n  const openRangeCalendarPicker = useCallback(() => {\n    setIsRangeCalendarPickerOpen(true)\n  }, [])\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && disabled, onChange, handleDisable)\n\n  useClickOutsideEffect([endDateInputRef, startDateInputRef], closeRangeCalendarPicker, baseContainer)\n\n  useEffect(() => {\n    if (!hasMountedRef.current) {\n      hasMountedRef.current = true\n\n      return\n    }\n\n    if (\n      (defaultValue &&\n        previousDefaultValue &&\n        defaultValue[0] instanceof Date &&\n        defaultValue[1] instanceof Date &&\n        previousDefaultValue[0] instanceof Date &&\n        previousDefaultValue[1] instanceof Date &&\n        defaultValue[0].toISOString() === previousDefaultValue[0].toISOString() &&\n        defaultValue[1].toISOString() === previousDefaultValue[1].toISOString()) ||\n      isEqual(defaultValue, previousDefaultValue)\n    ) {\n      return\n    }\n\n    selectedStartDateTimeAsDayjsRef.current = defaultValue ? customDayjs(defaultValue[0]) : undefined\n    selectedEndDateTimeAsDayjsRef.current = defaultValue ? customDayjs(defaultValue[1]) : undefined\n    selectedStartDateTupleRef.current = getUtcDateTupleFromDayjs(selectedStartDateTimeAsDayjsRef.current)\n    selectedEndDateTupleRef.current = getUtcDateTupleFromDayjs(selectedEndDateTimeAsDayjsRef.current)\n    selectedStartTimeTupleRef.current = getUtcTimeTupleFromDayjs(selectedStartDateTimeAsDayjsRef.current)\n    selectedEndTimeTupleRef.current = getUtcTimeTupleFromDayjs(selectedEndDateTimeAsDayjsRef.current)\n\n    forceUpdate()\n  }, [defaultValue, forceUpdate, previousDefaultValue])\n\n  return (\n    <Fieldset\n      className={controlledClassName}\n      disabled={disabled}\n      hasError={hasError}\n      isLegendHidden={isLabelHidden}\n      legend={label}\n      style={style}\n      {...nativeProps}\n    >\n      <Box $hasError={hasError} $isDisabled={disabled}>\n        <Field>\n          <DateInput\n            ref={startDateInputRef}\n            baseContainer={baseContainer || undefined}\n            disabled={disabled}\n            isCompact={isCompact}\n            isForcedFocused={isRangeCalendarPickerOpen}\n            isLight={isLight}\n            isRange\n            isStartDate\n            onChange={(nextDateTuple, isFilled) =>\n              handleDateInputChange(DateRangePosition.START, nextDateTuple, isFilled)\n            }\n            onClick={openRangeCalendarPicker}\n            onInput={callOnChangeUndefinedIfInputsAreEmpty}\n            onNext={handleStartDateInputNext}\n            value={selectedStartDateTupleRef.current}\n          />\n        </Field>\n\n        {withTime && (\n          <Field isTimeField>\n            <TimeInput\n              ref={startTimeInputRef}\n              baseContainer={baseContainer || undefined}\n              disabled={disabled}\n              isCompact={isCompact}\n              isLight={isLight}\n              isStartDate\n              minutesRange={minutesRange}\n              onBack={() => startDateInputRef.current?.focus(true)}\n              onChange={nextTimeTuple => handleTimeInputChange(DateRangePosition.START, nextTimeTuple)}\n              onFocus={closeRangeCalendarPicker}\n              onInput={callOnChangeUndefinedIfInputsAreEmpty}\n              onNext={() => endDateInputRef.current?.focus()}\n              onPrevious={() => startDateInputRef.current?.focus(true)}\n              value={selectedStartTimeTupleRef.current}\n            />\n          </Field>\n        )}\n\n        <Field isEndDateField>\n          <DateInput\n            ref={endDateInputRef}\n            baseContainer={baseContainer || undefined}\n            disabled={disabled}\n            isCompact={isCompact}\n            isEndDate\n            isForcedFocused={isRangeCalendarPickerOpen}\n            isLight={isLight}\n            isRange\n            onBack={handleEndDateInputPrevious}\n            onChange={(nextDateTuple, isFilled) =>\n              handleDateInputChange(DateRangePosition.END, nextDateTuple, isFilled)\n            }\n            onClick={openRangeCalendarPicker}\n            onInput={callOnChangeUndefinedIfInputsAreEmpty}\n            onNext={handleEndDateInputNext}\n            onPrevious={handleEndDateInputPrevious}\n            value={selectedEndDateTupleRef.current}\n          />\n        </Field>\n\n        {withTime && (\n          <Field isTimeField>\n            <TimeInput\n              ref={endTimeInputRef}\n              baseContainer={baseContainer || undefined}\n              disabled={disabled}\n              isCompact={isCompact}\n              isEndDate\n              isLight={isLight}\n              minutesRange={minutesRange}\n              onBack={() => endDateInputRef.current?.focus(true)}\n              onChange={nextTimeTuple => handleTimeInputChange(DateRangePosition.END, nextTimeTuple)}\n              onFocus={closeRangeCalendarPicker}\n              onInput={callOnChangeUndefinedIfInputsAreEmpty}\n              onPrevious={() => endDateInputRef.current?.focus(true)}\n              value={selectedEndTimeTupleRef.current}\n            />\n          </Field>\n        )}\n      </Box>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n\n      <RangeCalendarPicker\n        key={JSON.stringify(rangeCalendarPickerDefaultValue)}\n        defaultValue={rangeCalendarPickerDefaultValue}\n        isHistorical={isHistorical}\n        isOpen={isRangeCalendarPickerOpen}\n        onChange={handleRangeCalendarPickerChange}\n      />\n    </Fieldset>\n  )\n}\n\nconst Box = styled.div<{\n  $hasError: boolean\n  $isDisabled: boolean\n}>`\n  * {\n    font-weight: 500;\n    line-height: 1;\n  }\n\n  color: ${p => p.theme.color.gunMetal};\n  display: inline-flex;\n  font-size: 13px;\n  outline: ${p => (p.$hasError ? `1px solid ${p.theme.color.maximumRed}` : 0)};\n  position: relative;\n\n  ${p =>\n    p.$isDisabled &&\n    css`\n      * {\n        background-color: ${p.theme.color.cultured} !important;\n        color: ${p.theme.color.lightGray} !important;\n        cursor: not-allowed;\n      }\n    `}\n`\n\nconst Field = styled.span<{\n  isEndDateField?: boolean\n  isTimeField?: boolean\n}>`\n  font-size: inherit;\n  margin-left: ${p => {\n    if (p.isEndDateField) {\n      return '10px'\n    }\n\n    return p.isTimeField ? '2px' : 0\n  }};\n`\n","import classnames from 'classnames'\nimport { equals, includes, reject } from 'ramda'\nimport { useCallback, useMemo, type CSSProperties } from 'react'\nimport styled, { css } from 'styled-components'\n\nimport { Checkbox } from './Checkbox'\nimport { FieldError } from '../elements/FieldError'\nimport { Fieldset } from '../elements/Fieldset'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useKey } from '../hooks/useKey'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { Option, OptionValueType } from '../types'\nimport type { Promisable } from 'type-fest'\n\nexport type MultiCheckboxProps<OptionValue extends OptionValueType = string> = {\n  className?: string | undefined\n  disabled?: boolean | undefined\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isInline?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: OptionValue[] | undefined) => Promisable<void>) | undefined\n  options: Option<OptionValue>[]\n  style?: CSSProperties | undefined\n  value?: OptionValue[] | undefined\n}\nexport function MultiCheckbox<OptionValue extends OptionValueType = string>({\n  className,\n  disabled = false,\n  error,\n  isErrorMessageHidden = false,\n  isInline = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  name,\n  onChange,\n  options,\n  style,\n  value\n}: MultiCheckboxProps<OptionValue>) {\n  const controlledClassName = useMemo(() => classnames('Field-MultiCheckbox', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([value, disabled, name])\n\n  const handleChange = useCallback(\n    (nextOptionValue: OptionValue, isChecked: boolean) => {\n      if (!onChange) {\n        return\n      }\n\n      const nextCheckedOptionValues = isChecked\n        ? [...(value || []), nextOptionValue]\n        : reject(equals(nextOptionValue))(value || [])\n\n      const normalizedNextValue = nextCheckedOptionValues.length ? nextCheckedOptionValues : undefined\n\n      onChange(normalizedNextValue)\n    },\n    [onChange, value]\n  )\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && disabled, onChange)\n\n  return (\n    <Fieldset\n      className={controlledClassName}\n      disabled={disabled}\n      hasError={hasError}\n      isLegendHidden={isLabelHidden}\n      isLight={isLight}\n      legend={label}\n      style={style}\n    >\n      <ChecboxesBox key={key} $hasError={hasError} $isInline={isInline}>\n        {options.map((option, index) => (\n          <Checkbox\n            key={JSON.stringify(option.value)}\n            checked={includes(option.value, value || [])}\n            disabled={disabled}\n            label={option.label}\n            name={`${name}${index}`}\n            onChange={(isChecked: boolean) => handleChange(option.value, isChecked)}\n          />\n        ))}\n      </ChecboxesBox>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Fieldset>\n  )\n}\n\nconst ChecboxesBox = styled.div<{\n  $hasError: boolean\n  $isInline: boolean\n}>`\n  color: ${p => p.theme.color.gunMetal};\n  display: flex;\n  flex-direction: ${p => (p.$isInline ? 'row' : 'column')};\n\n  > div {\n    > .rs-checkbox {\n      user-select: none;\n    }\n  }\n  ${p =>\n    p.$hasError &&\n    css`\n      .rs-checkbox-wrapper .rs-checkbox-inner::before {\n        border-color: ${p.theme.color.maximumRed} !important;\n      }\n    `}\n\n  ${p =>\n    !p.$isInline &&\n    css`\n      > div:not(:first-child) {\n        > .rs-checkbox {\n          margin-top: 8px;\n        }\n      }\n    `}\n\n  ${p =>\n    p.$isInline &&\n    css`\n      > div:not(:first-child) {\n        .rs-checkbox {\n          margin-left: 12px;\n        }\n      }\n    `}\n`\n","import classnames from 'classnames'\nimport { useCallback, useEffect, useMemo, useRef, useState, type MouseEvent, type ReactNode } from 'react'\nimport { TagPicker, type TagPickerProps } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Field } from '../elements/Field'\nimport { FieldError } from '../elements/FieldError'\nimport { Label } from '../elements/Label'\nimport { useClickOutsideEffect } from '../hooks/useClickOutsideEffect'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useForceUpdate } from '../hooks/useForceUpdate'\nimport { useKey } from '../hooks/useKey'\nimport { type CustomSearch } from '../libs/CustomSearch'\nimport { type Option, type OptionValueType } from '../types'\nimport { getRsuiteDataFromOptions } from '../utils/getRsuiteDataFromOptions'\nimport { getRsuiteValueFromOptionValue } from '../utils/getRsuiteValueFromOptionValue'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { Promisable } from 'type-fest'\n\nexport type MultiSelectProps<OptionValue extends OptionValueType = string> = Omit<\n  TagPickerProps,\n  'as' | 'container' | 'data' | 'defaultValue' | 'id' | 'onChange' | 'open' | 'renderMenuItem' | 'value'\n> & {\n  /** Used to pass something else than `window.document` as a base container to attach global events listeners. */\n  baseContainer?: Document | HTMLDivElement | null | undefined\n  customSearch?: CustomSearch<Option<OptionValue>> | undefined\n  /** Minimum search query length required to trigger custom search filtering. */\n  customSearchMinQueryLength?: number | undefined\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: OptionValue[] | undefined) => Promisable<void>) | undefined\n  optionValueKey?: keyof OptionValue | undefined\n  options: Option<OptionValue>[]\n  value?: OptionValue[] | undefined\n}\nexport function MultiSelect<OptionValue extends OptionValueType = string>({\n  baseContainer,\n  className,\n  customSearch,\n  customSearchMinQueryLength = 1,\n  disabled = false,\n  error,\n  isErrorMessageHidden = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  onChange,\n  options,\n  optionValueKey,\n  searchable = false,\n  style,\n  value,\n  ...originalProps\n}: MultiSelectProps<OptionValue>) {\n  // eslint-disable-next-line no-null/no-null\n  const boxRef = useRef<HTMLDivElement | null>(null)\n  /** Instance of `CustomSearch` */\n  const customSearchRef = useRef(customSearch)\n\n  const controlledClassName = useMemo(() => classnames('Field-MultiSelect', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const rsuiteData = useMemo(() => getRsuiteDataFromOptions(options, optionValueKey), [options, optionValueKey])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([disabled, originalProps.name, value])\n  const selectedRsuiteValue = useMemo(\n    () => (value || []).map(valueItem => getRsuiteValueFromOptionValue(valueItem, optionValueKey)),\n    [optionValueKey, value]\n  )\n\n  // Only used when `customSearch` prop is set\n  const [controlledRsuiteData, setControlledRsuiteData] = useState(customSearch ? rsuiteData : undefined)\n  const [isOpen, setIsOpen] = useState(false)\n\n  const { forceUpdate } = useForceUpdate()\n\n  const close = useCallback(() => {\n    setIsOpen(false)\n  }, [])\n\n  const getOptionValuesFromRsuiteDataValues = useCallback(\n    (rsuiteValues: string[]) =>\n      rsuiteData.reduce((optionsValues, rsuiteDataItem) => {\n        if (!rsuiteValues.includes(rsuiteDataItem.value)) {\n          return optionsValues\n        }\n\n        return [...optionsValues, rsuiteDataItem.optionValue]\n      }, [] as OptionValue[]),\n    [rsuiteData]\n  )\n\n  const handleChange = useCallback(\n    (nextOptionRsuiteValues: string[] | null) => {\n      if (!onChange) {\n        return\n      }\n\n      const nextValue = nextOptionRsuiteValues ? getOptionValuesFromRsuiteDataValues(nextOptionRsuiteValues) : []\n      const normalizedNextValue = nextValue.length > 0 ? nextValue : undefined\n\n      setControlledRsuiteData(rsuiteData)\n\n      onChange(normalizedNextValue)\n    },\n    [getOptionValuesFromRsuiteDataValues, onChange, rsuiteData]\n  )\n\n  const handleSearch = useCallback(\n    (nextQuery: string) => {\n      if (!customSearchRef.current || nextQuery.trim().length < customSearchMinQueryLength) {\n        return\n      }\n\n      const nextControlledRsuiteData =\n        nextQuery.trim().length >= customSearchMinQueryLength\n          ? getRsuiteDataFromOptions(customSearchRef.current.find(nextQuery), optionValueKey)\n          : rsuiteData\n\n      setControlledRsuiteData(nextControlledRsuiteData)\n    },\n    [customSearchMinQueryLength, optionValueKey, rsuiteData]\n  )\n\n  const renderMenuItem = useCallback((node: ReactNode) => <span title={String(node)}>{String(node)}</span>, [])\n\n  const toggle = useCallback(\n    (event: MouseEvent<HTMLElement>) => {\n      let targetElement = event.target as HTMLElement\n\n      if (targetElement.tagName === 'path') {\n        if (targetElement.parentElement) {\n          targetElement = targetElement.parentElement\n        }\n      }\n\n      if (\n        targetElement.classList.contains('rs-picker-toggle') ||\n        targetElement.classList.contains('rs-picker-tag-wrapper') ||\n        targetElement.classList.contains('rs-picker-toggle-caret')\n      ) {\n        setIsOpen(!isOpen)\n      }\n    },\n    [isOpen]\n  )\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && disabled, onChange)\n\n  useClickOutsideEffect(boxRef, close, baseContainer)\n\n  useEffect(() => {\n    forceUpdate()\n  }, [forceUpdate])\n\n  return (\n    <Field className={controlledClassName} style={style}>\n      <Label disabled={disabled} hasError={hasError} htmlFor={originalProps.name} isHidden={isLabelHidden}>\n        {label}\n      </Label>\n\n      <Box ref={boxRef} $hasError={hasError} $isActive={isOpen} $isLight={isLight} onClick={toggle}>\n        {boxRef.current && (\n          <TagPicker\n            key={key}\n            container={boxRef.current}\n            // When we use a custom search, we use `controlledRsuiteData` to provide the matching options (data),\n            // when we don't, we don't need to control that and just pass the non-internally-controlled `rsuiteData`\n            data={controlledRsuiteData || rsuiteData}\n            disabled={disabled}\n            id={originalProps.name}\n            onChange={handleChange}\n            onClick={toggle}\n            onSearch={handleSearch}\n            open={isOpen}\n            renderMenuItem={renderMenuItem}\n            searchable={!!customSearch || searchable}\n            // When we use a custom search, we use `controlledRsuiteData` to provide the matching options (data),\n            // that's why we send this \"always true\" filter to disable Rsuite TagPicker internal search filtering\n            searchBy={(customSearch ? () => true : undefined) as any}\n            value={selectedRsuiteValue}\n            {...originalProps}\n          />\n        )}\n      </Box>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Field>\n  )\n}\n\nconst Box = styled.div<{\n  $hasError: boolean\n  $isActive: boolean\n  $isLight: boolean\n}>`\n  position: relative;\n  user-select: none;\n  width: 100%;\n\n  > .rs-picker-input {\n    background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)} !important;\n    border: solid 1px\n      ${p => {\n        if (p.$hasError) {\n          return p.theme.color.maximumRed\n        }\n        if (p.$isActive) {\n          return p.theme.color.blueGray[100]\n        }\n\n        return p.theme.color.gainsboro\n      }} !important;\n    cursor: pointer;\n    width: 100%;\n\n    :hover {\n      border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueYonder[100])} !important;\n    }\n\n    :active,\n    :focus {\n      border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100])} !important;\n    }\n\n    > .rs-picker-toggle {\n      background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)} !important;\n      border: 0;\n      bottom: 0;\n      cursor: inherit;\n      font-size: 13px;\n      height: 30px;\n      line-height: 1.3846;\n      padding: 5px 40px 0 8px !important;\n      top: 0;\n\n      > .rs-stack {\n        > .rs-stack-item {\n          > .rs-picker-toggle-placeholder {\n            font-size: 13px;\n            line-height: 1;\n            vertical-align: 1px;\n          }\n\n          .rs-picker-toggle-caret {\n            right: 10px;\n          }\n          .rs-picker-toggle-clean,\n          .rs-picker-toggle-caret {\n            padding: 0;\n            top: 5px;\n          }\n        }\n      }\n    }\n\n    > .rs-picker-tag-wrapper {\n      min-height: 30px;\n      padding: 0 !important;\n\n      > .rs-tag {\n        background-color: ${p => (p.$isLight ? p.theme.color.gainsboro : p.theme.color.white)};\n        font-size: 11px;\n        line-height: 1.3636; // = 15px\n\n        > .rs-tag-icon-close {\n          bottom: 0;\n          padding: 3px 6px;\n\n          > svg {\n            height: 10px;\n            width: 10px;\n          }\n        }\n      }\n\n      > .rs-picker-search {\n        > .rs-picker-search-input {\n          padding: 0 8px !important;\n\n          > input {\n            font-size: 13px;\n            line-height: 1.3846;\n          }\n        }\n      }\n    }\n  }\n\n  > .rs-picker-menu {\n    max-width: 100%;\n\n    > .rs-picker-check-menu {\n      margin: 0;\n\n      > div[role='option'] {\n        > .rs-check-item {\n          > .rs-checkbox-checker {\n            > label {\n              font-size: 13px;\n              line-height: 1.3846;\n              overflow: hidden;\n              padding: 8px 12px 8px 38px;\n              text-overflow: ellipsis;\n              white-space: nowrap;\n\n              > .rs-checkbox-wrapper {\n                left: 12px;\n                top: 10px !important;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`\n","import classnames from 'classnames'\nimport { equals } from 'ramda'\nimport { useCallback, useMemo, type CSSProperties } from 'react'\nimport { Radio } from 'rsuite'\nimport styled, { css } from 'styled-components'\n\nimport { FieldError } from '../elements/FieldError'\nimport { Fieldset } from '../elements/Fieldset'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useKey } from '../hooks/useKey'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { Option, OptionValueType } from '../types'\nimport type { Promisable } from 'type-fest'\n\nexport type MultiRadioProps<OptionValue extends OptionValueType = string> = {\n  className?: string | undefined\n  disabled?: boolean | undefined\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isInline?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: OptionValue | undefined) => Promisable<void>) | undefined\n  options: Option<OptionValue>[]\n  style?: CSSProperties | undefined\n  value?: OptionValue | undefined\n}\nexport function MultiRadio<OptionValue extends OptionValueType = string>({\n  className,\n  disabled = false,\n  error,\n  isErrorMessageHidden = false,\n  isInline = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  name,\n  onChange,\n  options,\n  style,\n  value\n}: MultiRadioProps<OptionValue>) {\n  const controlledClassName = useMemo(() => classnames('Field-MultiRadio', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([value, disabled, name])\n\n  const handleChange = useCallback(\n    (nextOptionValue: OptionValue, isChecked: boolean) => {\n      if (!onChange) {\n        return\n      }\n\n      const nextCheckedOptionValue = isChecked ? nextOptionValue : undefined\n\n      onChange(nextCheckedOptionValue)\n    },\n    [onChange]\n  )\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && disabled, onChange)\n\n  return (\n    <Fieldset\n      className={controlledClassName}\n      disabled={disabled}\n      hasError={hasError}\n      isLegendHidden={isLabelHidden}\n      isLight={isLight}\n      legend={label}\n      style={style}\n    >\n      <Box key={key} $hasError={hasError} $isInline={isInline}>\n        {options.map(option => (\n          <Radio\n            key={JSON.stringify(option.value)}\n            checked={equals(option.value, value)}\n            disabled={disabled}\n            name={name}\n            onChange={(_: any, isChecked: boolean) => handleChange(option.value, isChecked)}\n          >\n            {option.label}\n          </Radio>\n        ))}\n      </Box>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Fieldset>\n  )\n}\n\nconst Box = styled.div<{\n  $hasError: boolean\n  $isInline: boolean\n}>`\n  color: ${p => p.theme.color.gunMetal};\n  display: flex;\n  flex-direction: ${p => (p.$isInline ? 'row' : 'column')};\n  font-weight: 500;\n  outline: ${p => (p.$hasError ? `1px solid ${p.theme.color.maximumRed}` : 0)};\n\n  > .rs-radio {\n    * {\n      user-select: none;\n    }\n\n    > .rs-radio-checker {\n      min-height: 0;\n      padding: 0 0 0 28px;\n      user-select: none;\n\n      .rs-radio-wrapper {\n        left: 2px;\n        top: 3px !important;\n      }\n    }\n  }\n\n  ${p =>\n    !p.$isInline &&\n    css`\n      > .rs-radio:not(:first-child) {\n        margin-top: 6px;\n      }\n    `}\n\n  ${p =>\n    p.$isInline &&\n    css`\n      > .rs-radio:not(:first-child) {\n        margin-left: 12px;\n      }\n    `}\n`\n","// TODO Clean, split and finalize this component.\n\nimport classnames from 'classnames'\nimport { equals, remove } from 'ramda'\nimport { useCallback, useEffect, useMemo, useRef, useState, type CSSProperties } from 'react'\nimport styled from 'styled-components'\n\nimport { Accent } from '../../constants'\nimport { Button } from '../../elements/Button'\nimport { FieldError } from '../../elements/FieldError'\nimport { Fieldset } from '../../elements/Fieldset'\nimport { IconButton } from '../../elements/IconButton'\nimport { useFieldUndefineEffect } from '../../hooks/useFieldUndefineEffect'\nimport { Delete, Edit, Plus, SelectRectangle } from '../../icons'\nimport { normalizeString } from '../../utils/normalizeString'\n\nimport type { Promisable } from 'type-fest'\n\nexport type MultiZoneEditorProps = {\n  addButtonLabel: string\n  className?: string | undefined\n  defaultValue?: Record<string, any>[] | undefined\n  disabled?: boolean | undefined\n  error?: string | undefined\n  initialZone: Record<string, any>\n  isAddButtonDisabled?: boolean | undefined\n  isLabelHidden?: boolean\n  isLight?: boolean | undefined\n  label: string\n  labelPropName: string\n  onAdd?: ((nextZones: Record<string, any>[], index: number) => Promisable<void>) | undefined\n  onCenter?: ((zone: Record<string, any>) => Promisable<void>) | undefined\n  onChange?: ((nextZones: Record<string, any>[] | undefined) => Promisable<void>) | undefined\n  onDelete?: ((nextZones: Record<string, any>[]) => Promisable<void>) | undefined\n  onEdit?: ((zone: Record<string, any>, index: number) => Promisable<void>) | undefined\n  style?: CSSProperties | undefined\n}\nexport function MultiZoneEditor({\n  addButtonLabel,\n  className,\n  defaultValue = [],\n  disabled = false,\n  error,\n  initialZone,\n  isAddButtonDisabled = false,\n  isLabelHidden = false,\n  isLight = false,\n  label,\n  labelPropName,\n  onAdd,\n  onCenter,\n  onChange,\n  onDelete,\n  onEdit,\n  style\n}: MultiZoneEditorProps) {\n  const prevDefaultValueRef = useRef(defaultValue)\n\n  const [zones, setZones] = useState(defaultValue)\n\n  const controlledClassName = useMemo(() => classnames('Field-MultiZoneEditor', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n\n  const addZone = useCallback(() => {\n    const nextZones = [...zones, initialZone]\n\n    if (onAdd) {\n      onAdd(nextZones, nextZones.length)\n    }\n\n    setZones(nextZones)\n  }, [initialZone, onAdd, zones])\n\n  const centerZone = useCallback(\n    (zone: Record<string, any>) => {\n      if (onCenter) {\n        onCenter(zone)\n      }\n    },\n    [onCenter]\n  )\n\n  const deleteZone = useCallback(\n    (index: number) => {\n      const nextZones = remove(index, 1, zones)\n\n      setZones(nextZones)\n\n      if (onDelete) {\n        onDelete(nextZones)\n      }\n    },\n    [onDelete, zones]\n  )\n\n  const editZone = useCallback(\n    (index: number, zone: Record<string, any>) => {\n      if (onEdit) {\n        onEdit(zone, index)\n      }\n    },\n    [onEdit]\n  )\n\n  const handleDisable = useCallback(() => {\n    setZones([])\n  }, [])\n\n  useEffect(() => {\n    if (equals(defaultValue, prevDefaultValueRef.current)) {\n      return\n    }\n\n    setZones(defaultValue)\n  }, [defaultValue])\n\n  useFieldUndefineEffect(disabled, onChange, handleDisable)\n\n  return (\n    <Fieldset\n      className={controlledClassName}\n      disabled={disabled}\n      isLegendHidden={isLabelHidden}\n      legend={label}\n      style={style}\n    >\n      <Button\n        accent={Accent.SECONDARY}\n        disabled={disabled || isAddButtonDisabled}\n        Icon={Plus}\n        isFullWidth\n        onClick={addZone}\n      >\n        {addButtonLabel}\n      </Button>\n\n      <>\n        {zones.map((zone, index) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <Row key={`zone-${index}`}>\n            <ZoneBox $isLight={isLight}>\n              {zone[labelPropName]}\n\n              {/* TODO Add `Accent.LINK` accent in @mtes-mct/monitor-ui and use it here. */}\n              {/* eslint-disable-next-line jsx-a11y/anchor-is-valid, jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */}\n              <Link onClick={() => centerZone(zone)}>\n                <SelectRectangle />\n                <span>Centrer sur la carte</span>\n              </Link>\n            </ZoneBox>\n\n            <IconButton accent={Accent.SECONDARY} Icon={Edit} onClick={() => editZone(index, zone)} />\n            <IconButton\n              accent={Accent.SECONDARY}\n              aria-label=\"Supprimer cette zone\"\n              Icon={Delete}\n              onClick={() => deleteZone(index)}\n            />\n          </Row>\n        ))}\n      </>\n\n      {hasError && <FieldError>{controlledError}</FieldError>}\n    </Fieldset>\n  )\n}\n\nconst Row = styled.div`\n  align-items: center;\n  display: flex;\n  margin: 8px 0 0;\n\n  > button {\n    margin: 0 0 0 8px;\n  }\n`\n\nconst ZoneBox = styled.div<{\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  display: flex;\n  flex-grow: 1;\n  font-size: 13px;\n  line-height: 1.3077; // = 17px\n  justify-content: space-between;\n  padding: 6px 12px 6px;\n`\n\nconst Link = styled.a`\n  align-items: center;\n  cursor: pointer;\n  display: inline-flex;\n\n  > span {\n    line-height: 1;\n    margin: -2px 0 0 8px;\n  }\n`\n","import classnames from 'classnames'\nimport { useCallback, useMemo, useRef, type FocusEvent } from 'react'\nimport { Input, type InputProps } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Field } from '../elements/Field'\nimport { FieldError } from '../elements/FieldError'\nimport { Label } from '../elements/Label'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useKey } from '../hooks/useKey'\nimport { usePreventWheelEvent } from '../hooks/usePreventWheelEvent'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { Promisable } from 'type-fest'\n\nexport type NumberInputProps = Omit<InputProps, 'as' | 'defaultValue' | 'id' | 'onChange' | 'type' | 'value'> & {\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: number | undefined) => Promisable<void>) | undefined\n  value?: number | undefined\n}\nexport function NumberInput({\n  className,\n  error,\n  isErrorMessageHidden = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  onBlur,\n  onChange,\n  onFocus,\n  style,\n  value,\n  ...originalProps\n}: NumberInputProps) {\n  // eslint-disable-next-line no-null/no-null\n  const inputRef = useRef<HTMLInputElement | null>(null)\n\n  const controlledClassname = useMemo(() => classnames('Field-NumberInput', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([originalProps.disabled, originalProps.name])\n\n  const preventWheelEvent = usePreventWheelEvent(inputRef)\n\n  const handleChange = useCallback(\n    (nextValue: string) => {\n      if (!onChange) {\n        return\n      }\n\n      const normalizedNextValueAsString = nextValue && nextValue.length ? nextValue : undefined\n      const nextValueAsNumber = Number(normalizedNextValueAsString)\n      const normalizedNextValue = !Number.isNaN(nextValueAsNumber) ? nextValueAsNumber : undefined\n\n      onChange(normalizedNextValue)\n    },\n    [onChange]\n  )\n\n  const handleBlur = useCallback(\n    (event: FocusEvent<HTMLInputElement>) => {\n      event.target.removeEventListener('wheel', preventWheelEvent)\n\n      if (onBlur) {\n        onBlur(event)\n      }\n    },\n    [onBlur, preventWheelEvent]\n  )\n\n  const handleFocus = useCallback(\n    (event: FocusEvent<HTMLInputElement>) => {\n      event.target.addEventListener('wheel', preventWheelEvent)\n\n      if (onFocus) {\n        onFocus(event)\n      }\n    },\n    [onFocus, preventWheelEvent]\n  )\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && originalProps.disabled, onChange)\n\n  return (\n    <Field className={controlledClassname} style={style}>\n      <Label\n        disabled={originalProps.disabled}\n        hasError={hasError}\n        htmlFor={originalProps.name}\n        isHidden={isLabelHidden}\n      >\n        {label}\n      </Label>\n\n      <StyledInput\n        key={key}\n        ref={inputRef}\n        $hasError={hasError}\n        $isLight={isLight}\n        id={originalProps.name}\n        onBlur={handleBlur}\n        onChange={handleChange}\n        onFocus={handleFocus}\n        type=\"number\"\n        value={value || ''}\n        {...originalProps}\n      />\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Field>\n  )\n}\n\nconst StyledInput = styled(Input)<{\n  $hasError: boolean\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.gainsboro)};\n  border-radius: 0;\n  font-size: 13px;\n  /* TODO It should be 18px but computed line-height is stuck to min. 18.5px. Investigate that. */\n  line-height: 19px;\n  padding: 3px 8px 6px;\n  vertical-align: center;\n  width: 100%;\n\n  :hover {\n    border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueYonder[100])} !important;\n  }\n\n  :active,\n  :focus {\n    border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100])} !important;\n    outline: 0;\n  }\n`\n","import { useMemo, useRef, useState } from 'react'\nimport styled from 'styled-components'\nimport { useDebouncedCallback } from 'use-debounce'\n\nimport { isNumeric } from '../../utils/isNumeric'\n\nimport type { Coordinates } from '../../types'\n\ntype DDCoordinatesInputProps = {\n  coordinates: Coordinates | undefined\n  disabled: boolean | undefined\n  onChange: (nextCoordinates: Coordinates, coordinates: Coordinates | undefined) => void\n}\n// TODO This field should return undefined when cleared (i.e.: Select all & Backspace/Delete)\nexport function DDCoordinatesInput({ coordinates, disabled = false, onChange }: DDCoordinatesInputProps) {\n  const latitudeInputRef = useRef<HTMLInputElement>()\n  const longitudeInputRef = useRef<HTMLInputElement>()\n\n  const [latitudeError, setLatitudeError] = useState('')\n  const [longitudeError, setLongitudeError] = useState('')\n\n  const defaultValue = useMemo(() => {\n    if (!coordinates) {\n      return undefined\n    }\n\n    const [latitude, longitude] = coordinates\n\n    if (isNumeric(latitude) && isNumeric(longitude)) {\n      return {\n        latitude: Number(latitude),\n        longitude: Number(longitude)\n      }\n    }\n\n    return {\n      latitude: undefined,\n      longitude: undefined\n    }\n  }, [coordinates])\n\n  const handleChange = useDebouncedCallback((nextCoordinates: [number, number] | undefined) => {\n    if (!latitudeInputRef.current || !longitudeInputRef.current) {\n      return\n    }\n\n    const latitudeAsString = latitudeInputRef.current.value\n    const longitudeAsString = longitudeInputRef.current.value\n\n    setLongitudeError('')\n    setLatitudeError('')\n\n    if (!isNumeric(latitudeAsString)) {\n      setLatitudeError('Champ Latitude incorrect')\n\n      return\n    }\n\n    if (!isNumeric(longitudeAsString)) {\n      setLongitudeError('Champ Longitude incorrect')\n\n      return\n    }\n\n    const latitude = Number(latitudeAsString)\n    const longitude = Number(longitudeAsString)\n\n    onChange([latitude, longitude], nextCoordinates)\n  }, 500)\n\n  return (\n    <Box>\n      <DDInput\n        ref={latitudeInputRef as any}\n        data-cy=\"coordinates-dd-input-lat\"\n        defaultValue={defaultValue ? defaultValue.latitude : undefined}\n        disabled={disabled}\n        onChange={() => handleChange(coordinates)}\n        placeholder=\"Latitude\"\n        style={{ border: latitudeError ? '1px solid red' : undefined }}\n      />\n      <DDInput\n        ref={longitudeInputRef as any}\n        data-cy=\"coordinates-dd-input-lon\"\n        defaultValue={defaultValue ? defaultValue.longitude : undefined}\n        disabled={disabled}\n        onChange={() => handleChange(coordinates)}\n        placeholder=\"Longitude\"\n        style={{ border: longitudeError ? '1px solid red' : undefined }}\n      />\n      <CoordinatesType>(DD)</CoordinatesType>\n      <Error>{latitudeError}</Error>\n      <Error>{longitudeError}</Error>\n    </Box>\n  )\n}\n\nconst DDInput = styled.input`\n  margin-right: 5px !important;\n  width: 100px;\n`\n\nconst CoordinatesType = styled.span`\n  margin-left: 7px;\n  color: ${p => p.theme.color.slateGray};\n`\n\nconst Error = styled.span`\n  color: red;\n  display: block;\n`\n\nconst Box = styled.div`\n  font-size: 13px;\n  text-align: left;\n`\n","import { useEffect, useState } from 'react'\nimport { dmsToDecimal } from 'react-coordinate-input'\nimport { IMaskInput } from 'react-imask'\nimport styled from 'styled-components'\n\nimport { CoordinatesFormat, WSG84_PROJECTION } from '../../constants'\nimport { getCoordinates } from '../../utils/coordinates'\nimport { isNumeric } from '../../utils/isNumeric'\n\nimport type { Coordinates } from '../../types'\n\n// TODO Remove that once the fix is added and released.\n// Open issue: https://github.com/uNmAnNeR/imaskjs/issues/761\nconst UntypedIMaskInput: any = IMaskInput\n\ntype DMDCoordinatesInputProps = {\n  coordinates: Coordinates | undefined\n  coordinatesFormat: CoordinatesFormat\n  disabled: boolean | undefined\n  onChange: (nextCoordinates: Coordinates, coordinates: Coordinates | undefined) => void\n}\n// TODO This field should return undefined when cleared (i.e.: Select all & Backspace/Delete)\nexport function DMDCoordinatesInput({\n  coordinates,\n  coordinatesFormat,\n  disabled = false,\n  onChange\n}: DMDCoordinatesInputProps) {\n  const [error, setError] = useState('')\n  const [value, setValue] = useState('')\n\n  useEffect(() => {\n    if (coordinates?.length && coordinatesFormat) {\n      const nextValue = getCoordinates(\n        [coordinates[1], coordinates[0]],\n        WSG84_PROJECTION,\n        CoordinatesFormat.DEGREES_MINUTES_DECIMALS\n      )\n        .map(coordinate => coordinate.replace(/[. ]/g, ''))\n        .join('')\n\n      setValue(nextValue)\n    } else {\n      setValue('')\n    }\n  }, [coordinates, coordinatesFormat])\n\n  function completeCoordinates(mask) {\n    setError('')\n\n    // eslint-disable-next-line no-underscore-dangle\n    const latitude = mask._unmaskedValue.substring(0, 7)\n    // eslint-disable-next-line no-underscore-dangle\n    const longitude = mask._unmaskedValue.substring(7, mask._unmaskedValue.length)\n    const NS = latitude[latitude.length - 1].toUpperCase()\n    if (!['N', 'S'].includes(NS)) {\n      setError('La latitude doit tre N ou S')\n\n      return\n    }\n    const latitudeDegrees = parseInt(latitude.substring(0, 2), 10)\n    if (latitudeDegrees < 0 || latitudeDegrees > 90) {\n      setError('La latitude doit tre comprise entre 0 et 90')\n\n      return\n    }\n    const latitudeMinutes = parseInt(latitude.substring(2, 4), 10)\n    const latitudeSeconds = parseInt(latitude.substring(4, 6), 10)\n\n    const EW = longitude[longitude.length - 1].toUpperCase()\n    if (!['E', 'W'].includes(EW)) {\n      setError('La longitude doit tre E ou W')\n\n      return\n    }\n    const longitudeDegrees = parseInt(longitude.substring(0, 3), 10)\n    if (longitudeDegrees < 0 || longitudeDegrees > 180) {\n      setError('La longitude doit tre comprise entre 0 et 180')\n\n      return\n    }\n    const longitudeMinutes = parseInt(longitude.substring(3, 5), 10)\n    const longitudeSeconds = parseInt(longitude.substring(5, 7), 10)\n\n    const dLatitude = dmsToDecimal(latitudeDegrees, latitudeMinutes + 10 ** -2 * latitudeSeconds, 0, NS, 6)\n    const dLongitude = dmsToDecimal(longitudeDegrees, longitudeMinutes + 10 ** -2 * longitudeSeconds, 0, EW, 6)\n\n    if (isNumeric(dLatitude) && isNumeric(dLongitude)) {\n      onChange([dLatitude as number, dLongitude as number], coordinates)\n    } else {\n      setError('Format lat/long invalide')\n    }\n  }\n\n  return (\n    <Box>\n      <UntypedIMaskInput\n        data-cy=\"dmd-coordinates-input\"\n        disabled={disabled}\n        lazy={false}\n        mask=\"00 00.00 a 000 00.00 a\"\n        // @ts-ignore\n        onAccept={(_, mask) => setValue(mask.value)}\n        onComplete={(_, mask) => completeCoordinates(mask)}\n        placeholder=\"__ __.___ _ ___ __.___\"\n        radix=\".\"\n        style={{ border: error ? '1px solid red' : undefined }}\n        // TODO Use `defaultValue` here.\n        value={value}\n      />\n      <CoordinatesType>(DMD)</CoordinatesType>\n      <Error>{error}</Error>\n    </Box>\n  )\n}\n\nconst CoordinatesType = styled.span`\n  margin-left: 7px;\n  color: ${p => p.theme.color.slateGray};\n`\n\nconst Error = styled.span`\n  color: ${p => p.theme.color.maximumRed};\n  display: inline-block;\n`\n\nconst Box = styled.div`\n  font-size: 13px;\n  text-align: left;\n`\n","import { isEmpty } from 'ramda'\nimport { useCallback, useMemo } from 'react'\nimport CoordinateInput from 'react-coordinate-input'\nimport styled from 'styled-components'\n\nimport type { CoordinatesFormat } from '../../constants'\nimport type { Coordinates } from '../../types'\n\ntype DMSCoordinatesInputProps = {\n  coordinates: Coordinates | undefined\n  coordinatesFormat: CoordinatesFormat\n  disabled: boolean | undefined\n  onChange: (nextCoordinates: Coordinates | undefined, coordinates: Coordinates | undefined) => void\n}\nexport function DMSCoordinatesInput({\n  coordinates,\n  coordinatesFormat,\n  disabled = false,\n  onChange\n}: DMSCoordinatesInputProps) {\n  /** Convert the coordinates to the [latitude, longitude] string format */\n  const defaultValue = useMemo(() => {\n    if (!coordinates?.length || !coordinatesFormat) {\n      return ''\n    }\n\n    return coordinates?.join(', ') || ''\n  }, [coordinates, coordinatesFormat])\n\n  const update = useCallback(\n    nextCoordinates => {\n      const normalizedNextCoordinates = !isEmpty(nextCoordinates) ? nextCoordinates : undefined\n\n      onChange(normalizedNextCoordinates, coordinates)\n    },\n    [coordinates, onChange]\n  )\n\n  return (\n    <Box>\n      <CoordinateInput\n        data-cy=\"dms-coordinates-input\"\n        ddPrecision={6}\n        disabled={disabled}\n        onChange={(_, { dd }) => update(dd)}\n        // TODO Use `defaultValue` here.\n        value={defaultValue}\n      />\n      <CoordinatesType>(DMS)</CoordinatesType>\n    </Box>\n  )\n}\n\nconst CoordinatesType = styled.span`\n  margin-left: 7px;\n  color: ${p => p.theme.color.slateGray};\n`\n\nconst Box = styled.div`\n  font-size: 13px;\n  text-align: left;\n`\n","import classnames from 'classnames'\nimport { noop } from 'lodash/fp'\nimport { useCallback, useMemo } from 'react'\nimport styled from 'styled-components'\n\nimport { DDCoordinatesInput } from './DDCoordinatesInput'\nimport { DMDCoordinatesInput } from './DMDCoordinatesInput'\nimport { DMSCoordinatesInput } from './DMSCoordinatesInput'\nimport { CoordinatesFormat } from '../../constants'\nimport { FieldError } from '../../elements/FieldError'\nimport { Fieldset } from '../../elements/Fieldset'\nimport { useFieldUndefineEffect } from '../../hooks/useFieldUndefineEffect'\nimport { normalizeString } from '../../utils/normalizeString'\n\nimport type { FieldsetProps } from '../../elements/Fieldset'\nimport type { Coordinates } from '../../types'\nimport type { Promisable } from 'type-fest'\n\nexport type CoordinatesInputProps = FieldsetProps & {\n  coordinatesFormat: CoordinatesFormat\n  defaultValue?: Coordinates | undefined\n  disabled?: boolean | undefined\n  error?: string | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  label: string\n  onChange?:\n    | ((nextCoordinates: Coordinates | undefined, coordinates: Coordinates | undefined) => Promisable<void>)\n    | undefined\n}\nexport function CoordinatesInput({\n  className,\n  coordinatesFormat,\n  defaultValue,\n  error,\n  isLabelHidden = false,\n  isLight = false,\n  label,\n  onChange = noop,\n  ...nativeProps\n}: CoordinatesInputProps) {\n  const controlledClassName = classnames('Field-CoordinatesInput', className)\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n\n  const getCoordinatesInput = useCallback(() => {\n    switch (coordinatesFormat) {\n      case CoordinatesFormat.DEGREES_MINUTES_SECONDS:\n        return (\n          <DMSCoordinatesInput\n            coordinates={defaultValue}\n            coordinatesFormat={CoordinatesFormat.DEGREES_MINUTES_SECONDS}\n            disabled={nativeProps.disabled}\n            onChange={onChange}\n          />\n        )\n\n      case CoordinatesFormat.DEGREES_MINUTES_DECIMALS:\n        return (\n          <DMDCoordinatesInput\n            coordinates={defaultValue}\n            coordinatesFormat={CoordinatesFormat.DEGREES_MINUTES_DECIMALS}\n            disabled={nativeProps.disabled}\n            onChange={onChange}\n          />\n        )\n\n      case CoordinatesFormat.DECIMAL_DEGREES:\n        return (\n          <DDCoordinatesInput\n            coordinates={defaultValue as [number, number]}\n            disabled={nativeProps.disabled}\n            onChange={onChange}\n          />\n        )\n\n      default:\n        return undefined\n    }\n  }, [defaultValue, nativeProps.disabled, onChange, coordinatesFormat])\n\n  // TODO We must add a `handleDisable()` callback here to effectively empty the inputs when disabling this field.\n  useFieldUndefineEffect(nativeProps.disabled, onChange /* , handleDisable */)\n\n  return (\n    <StyledFieldset\n      className={controlledClassName}\n      isLegendHidden={isLabelHidden}\n      isLight={isLight}\n      legend={label}\n      {...nativeProps}\n    >\n      {getCoordinatesInput()}\n\n      {hasError && <FieldError>{controlledError}</FieldError>}\n    </StyledFieldset>\n  )\n}\n\nconst StyledFieldset = styled(Fieldset)`\n  input {\n    background-color: ${p => (p.isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n    border: ${p => (p.isLight ? `1px solid ${p.theme.color.lightGray}` : 'none')};\n    color: ${p => p.theme.color.gunMetal};\n    height: 33px;\n    padding: 7px 11px;\n  }\n`\n","import classnames from 'classnames'\nimport { useCallback, useEffect, useMemo, useRef, useState, type MouseEvent, type ReactNode } from 'react'\nimport { SelectPicker, type SelectPickerProps } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Field } from '../elements/Field'\nimport { FieldError } from '../elements/FieldError'\nimport { Label } from '../elements/Label'\nimport { useClickOutsideEffect } from '../hooks/useClickOutsideEffect'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useForceUpdate } from '../hooks/useForceUpdate'\nimport { useKey } from '../hooks/useKey'\nimport { type CustomSearch } from '../libs/CustomSearch'\nimport { type Option, type OptionAsRsuiteItemDataType, type OptionValueType } from '../types'\nimport { getRsuiteDataFromOptions } from '../utils/getRsuiteDataFromOptions'\nimport { getRsuiteValueFromOptionValue } from '../utils/getRsuiteValueFromOptionValue'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { Promisable } from 'type-fest'\n\nexport type SelectProps<OptionValue extends OptionValueType = string> = Omit<\n  SelectPickerProps<any>,\n  | 'as'\n  | 'container'\n  | 'data'\n  | 'defaultValue'\n  | 'id'\n  | 'onChange'\n  | 'open'\n  | 'renderMenuItem'\n  | 'renderValue'\n  | 'value'\n  | 'valueKey'\n> & {\n  /** Used to pass something else than `window.document` as a base container to attach global events listeners. */\n  baseContainer?: Document | HTMLDivElement | null | undefined\n  customSearch?: CustomSearch<Option<OptionValue>> | undefined\n  /** Minimum search query length required to trigger custom search filtering. */\n  customSearchMinQueryLength?: number | undefined\n  error?: string | undefined\n  isCleanable?: boolean | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: OptionValue | undefined) => Promisable<void>) | undefined\n  optionValueKey?: keyof OptionValue | undefined\n  options: Option<OptionValue>[]\n  value?: OptionValue | undefined\n}\nexport function Select<OptionValue extends OptionValueType = string>({\n  baseContainer,\n  className,\n  customSearch,\n  customSearchMinQueryLength = 1,\n  disabled = false,\n  error,\n  isCleanable = true,\n  isErrorMessageHidden = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  onChange,\n  options,\n  optionValueKey,\n  searchable = false,\n  style,\n  value,\n  ...originalProps\n}: SelectProps<OptionValue>) {\n  // eslint-disable-next-line no-null/no-null\n  const boxRef = useRef<HTMLDivElement | null>(null)\n  /** Instance of `CustomSearch` */\n  const customSearchRef = useRef(customSearch)\n\n  const { forceUpdate } = useForceUpdate()\n\n  const controlledClassname = useMemo(() => classnames('Field-Select', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const rsuiteData = useMemo(() => getRsuiteDataFromOptions(options, optionValueKey), [options, optionValueKey])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([disabled, originalProps.name, value])\n  const selectedRsuiteValue = useMemo(\n    () => getRsuiteValueFromOptionValue(value, optionValueKey),\n    [value, optionValueKey]\n  )\n\n  // Only used when `customSearch` prop is set\n  const [controlledRsuiteData, setControlledRsuiteData] = useState(customSearch ? rsuiteData : undefined)\n  const [isOpen, setIsOpen] = useState(false)\n\n  const close = useCallback(() => {\n    setIsOpen(false)\n  }, [])\n\n  const handleClean = useCallback(() => {\n    if (!onChange) {\n      return\n    }\n\n    onChange(undefined)\n  }, [onChange])\n\n  const handleSearch = useCallback(\n    (nextQuery: string) => {\n      if (!customSearchRef.current || nextQuery.trim().length < customSearchMinQueryLength) {\n        return\n      }\n\n      const nextControlledRsuiteData =\n        nextQuery.trim().length >= customSearchMinQueryLength\n          ? getRsuiteDataFromOptions(customSearchRef.current.find(nextQuery), optionValueKey)\n          : rsuiteData\n\n      setControlledRsuiteData(nextControlledRsuiteData)\n    },\n    [customSearchMinQueryLength, optionValueKey, rsuiteData]\n  )\n\n  const handleSelect = useCallback(\n    (_: string, selectedItem: OptionAsRsuiteItemDataType<OptionValue>) => {\n      close()\n\n      if (onChange) {\n        onChange(selectedItem.optionValue)\n      }\n    },\n    [close, onChange]\n  )\n\n  const renderMenuItem = useCallback((node: ReactNode) => <span title={String(node)}>{String(node)}</span>, [])\n\n  const toggle = useCallback(\n    (event: MouseEvent<HTMLElement>) => {\n      let targetElement = event.target as HTMLElement\n\n      if (targetElement.tagName === 'path') {\n        if (targetElement.parentElement) {\n          targetElement = targetElement.parentElement\n        }\n      }\n\n      if (\n        targetElement.classList.contains('rs-picker-toggle') ||\n        targetElement.classList.contains('rs-picker-toggle-value') ||\n        targetElement.classList.contains('rs-stack-item') ||\n        targetElement.classList.contains('rs-picker-toggle-caret') ||\n        targetElement.classList.contains('rs-picker-toggle-placeholder')\n      ) {\n        setIsOpen(!isOpen)\n      }\n    },\n    [isOpen]\n  )\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && disabled, onChange)\n\n  useClickOutsideEffect(boxRef, close, baseContainer)\n\n  useEffect(() => {\n    forceUpdate()\n  }, [forceUpdate])\n\n  return (\n    <Field className={controlledClassname} style={style}>\n      <Label disabled={disabled} hasError={hasError} htmlFor={originalProps.name} isHidden={isLabelHidden}>\n        {label}\n      </Label>\n\n      <Box ref={boxRef} $hasError={hasError} onClick={toggle}>\n        {boxRef.current && (\n          <StyledSelectPicker\n            key={key}\n            $isLight={isLight}\n            cleanable={isCleanable}\n            container={boxRef.current}\n            // When we use a custom search, we use `controlledRsuiteData` to provide the matching options (data),\n            // when we don't, we don't need to control that and just pass the non-internally-controlled `rsuiteData`\n            data={controlledRsuiteData || rsuiteData}\n            disabled={disabled}\n            id={originalProps.name}\n            onClean={handleClean}\n            onSearch={handleSearch}\n            // `as any` because we customized `ItemDataType` type by adding `optionValue`,\n            // which generates an optional vs required type conflict\n            onSelect={handleSelect as any}\n            open={isOpen}\n            renderMenuItem={renderMenuItem}\n            searchable={!!customSearch || searchable}\n            // When we use a custom search, we use `controlledRsuiteData` to provide the matching options (data),\n            // that's why we send this \"always true\" filter to disable Rsuite SelectPicker internal search filtering\n            searchBy={(customSearch ? () => true : undefined) as any}\n            value={selectedRsuiteValue}\n            {...originalProps}\n          />\n        )}\n      </Box>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Field>\n  )\n}\n\nconst StyledSelectPicker = styled(SelectPicker)<{\n  $isLight: boolean\n}>`\n  > .rs-picker-toggle {\n    background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)} !important;\n    border: 0;\n  }\n`\n\nconst Box = styled.div<{\n  $hasError: boolean\n}>`\n  position: relative;\n  user-select: none;\n  width: 100%;\n\n  > .rs-picker-select {\n    width: 100%;\n\n    > .rs-picker-toggle {\n      border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.gainsboro)} !important;\n      font-size: 13px;\n      line-height: 1.3846;\n      padding: 4px 40px 6px 8px;\n\n      :hover {\n        border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueYonder[100])} !important;\n      }\n\n      :active,\n      :focus {\n        border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100])} !important;\n      }\n\n      > .rs-stack {\n        > .rs-stack-item {\n          > .rs-picker-toggle-placeholder {\n            font-size: 13px;\n            line-height: 1.3846;\n          }\n\n          > .rs-picker-toggle-clean.rs-btn-close {\n            top: 4px !important;\n          }\n\n          > svg {\n            height: 18px;\n            margin-top: -2px;\n          }\n        }\n      }\n    }\n  }\n\n  > .rs-picker-menu {\n    max-width: 100%;\n\n    > .rs-picker-search-bar {\n      > .rs-picker-search-bar-input {\n        background-color: ${p => p.theme.color.white};\n        border: solid 1px ${p => p.theme.color.lightGray};\n        border-radius: 0;\n        font-size: 13px;\n        padding: 4px 8px 6px 8px;\n      }\n\n      > svg {\n        color: ${p => p.theme.color.lightGray};\n        top: 11px;\n      }\n    }\n\n    > .rs-picker-select-menu {\n      > div[role='option'] {\n        > .rs-picker-select-menu-item {\n          font-size: 13px;\n          line-height: 1.3846;\n          overflow: hidden;\n          padding: 6px 12px 10px 12px;\n          text-overflow: ellipsis;\n          white-space: nowrap;\n        }\n      }\n    }\n  }\n`\n","import classnames from 'classnames'\nimport { useCallback, useMemo, useRef } from 'react'\nimport { Input } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Field } from '../elements/Field'\nimport { FieldError } from '../elements/FieldError'\nimport { Label } from '../elements/Label'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useKey } from '../hooks/useKey'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { MutableRefObject, TextareaHTMLAttributes } from 'react'\nimport type { Promisable } from 'type-fest'\n\nexport type TextareaProps = Omit<\n  TextareaHTMLAttributes<HTMLTextAreaElement>,\n  'defaultValue' | 'id' | 'onChange' | 'value'\n> & {\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: string | undefined) => Promisable<void>) | undefined\n  value?: string | undefined\n}\nexport function Textarea({\n  className,\n  error,\n  isErrorMessageHidden = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  onChange,\n  rows = 3,\n  style,\n  value,\n  ...originalProps\n}: TextareaProps) {\n  const inputRef = useRef() as MutableRefObject<HTMLTextAreaElement>\n\n  const controlledClassname = useMemo(() => classnames('Field-Textarea', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([originalProps.disabled, originalProps.name])\n\n  const handleChange = useCallback(() => {\n    if (!onChange) {\n      return\n    }\n\n    const nextValue = inputRef.current.value\n    const normalizedNextValue = nextValue.trim().length ? nextValue : undefined\n\n    onChange(normalizedNextValue)\n  }, [onChange])\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && originalProps.disabled, onChange)\n\n  return (\n    <Field className={controlledClassname} style={style}>\n      <Label\n        disabled={originalProps.disabled}\n        hasError={hasError}\n        htmlFor={originalProps.name}\n        isHidden={isLabelHidden}\n      >\n        {label}\n      </Label>\n\n      <StyledInput\n        key={key}\n        ref={inputRef}\n        $hasError={hasError}\n        $isLight={isLight}\n        as=\"textarea\"\n        id={originalProps.name}\n        onChange={handleChange}\n        rows={rows}\n        value={value || ''}\n        {...originalProps}\n      />\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Field>\n  )\n}\n\nconst StyledInput = styled(Input)<{\n  $hasError: boolean\n  $isLight: boolean\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.gainsboro)};\n  font-size: 13px;\n  padding: 7px 11px;\n  width: 100%;\n\n  ::placeholder {\n    color: ${p => (p.$isLight ? p.theme.color.slateGray : p.theme.color.slateGray)};\n  }\n\n  :hover {\n    border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueYonder[100])} !important;\n  }\n\n  :active,\n  :focus {\n    border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100])} !important;\n    outline: 0;\n  }\n`\n","import classnames from 'classnames'\nimport { type FunctionComponent, useCallback, useMemo } from 'react'\nimport { Input } from 'rsuite'\nimport styled from 'styled-components'\n\nimport { Size } from '../constants'\nimport { Field } from '../elements/Field'\nimport { FieldError } from '../elements/FieldError'\nimport { Label } from '../elements/Label'\nimport { useFieldUndefineEffect } from '../hooks/useFieldUndefineEffect'\nimport { useKey } from '../hooks/useKey'\nimport { THEME } from '../theme'\nimport { normalizeString } from '../utils/normalizeString'\n\nimport type { IconProps } from '../types'\nimport type { InputProps } from 'rsuite'\nimport type { Promisable } from 'type-fest'\n\nexport type TextInputProps = Omit<InputProps, 'as' | 'defaultValue' | 'id' | 'onChange' | 'size' | 'type' | 'value'> & {\n  Icon?: FunctionComponent<IconProps> | undefined\n  error?: string | undefined\n  isErrorMessageHidden?: boolean | undefined\n  isLabelHidden?: boolean | undefined\n  isLight?: boolean | undefined\n  isUndefinedWhenDisabled?: boolean | undefined\n  label: string\n  name: string\n  onChange?: ((nextValue: string | undefined) => Promisable<void>) | undefined\n  size?: Size | undefined\n  value?: string | undefined\n}\nexport function TextInput({\n  className,\n  error,\n  Icon,\n  isErrorMessageHidden = false,\n  isLabelHidden = false,\n  isLight = false,\n  isUndefinedWhenDisabled = false,\n  label,\n  onChange,\n  size = Size.NORMAL,\n  style,\n  value,\n  ...originalProps\n}: TextInputProps) {\n  const controlledClassname = useMemo(() => classnames('Field-TextInput', className), [className])\n  const controlledError = useMemo(() => normalizeString(error), [error])\n  const hasError = useMemo(() => Boolean(controlledError), [controlledError])\n  const key = useKey([originalProps.disabled, originalProps.name])\n\n  const handleChange = useCallback(\n    (nextValue: string | null) => {\n      if (!onChange) {\n        return\n      }\n\n      const normalizedNextValue = nextValue && nextValue.trim().length ? nextValue : undefined\n\n      onChange(normalizedNextValue)\n    },\n    [onChange]\n  )\n\n  useFieldUndefineEffect(isUndefinedWhenDisabled && originalProps.disabled, onChange)\n\n  return (\n    <Field className={controlledClassname} style={style}>\n      <Label\n        disabled={originalProps.disabled}\n        hasError={hasError}\n        htmlFor={originalProps.name}\n        isHidden={isLabelHidden}\n      >\n        {label}\n      </Label>\n\n      <InputBox $size={size}>\n        <StyledInput\n          key={key}\n          $hasError={hasError}\n          $hasIcon={!!Icon}\n          $isLight={isLight}\n          $size={size}\n          id={originalProps.name}\n          onChange={handleChange}\n          type=\"text\"\n          value={value || ''}\n          {...originalProps}\n        />\n\n        {Icon && <Icon color={THEME.color.slateGray} />}\n      </InputBox>\n\n      {!isErrorMessageHidden && hasError && <FieldError>{controlledError}</FieldError>}\n    </Field>\n  )\n}\n\nconst PADDING: Record<Size, string> = {\n  [Size.LARGE]: '8px 16px 11px',\n  [Size.NORMAL]: '3px 8px 6px',\n  [Size.SMALL]: '3px 8px 6px'\n}\nconst PADDING_WITH_ICON: Record<Size, string> = {\n  [Size.LARGE]: '8px 40px 11px 16px',\n  [Size.NORMAL]: '3px 38px 6px 8px',\n  [Size.SMALL]: '3px 38px 6px 8px'\n}\nconst StyledInput = styled(Input)<{\n  $hasError: boolean\n  $hasIcon: boolean\n  $isLight: boolean\n  $size: Size\n}>`\n  background-color: ${p => (p.$isLight ? p.theme.color.white : p.theme.color.gainsboro)};\n  border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.gainsboro)};\n  border-radius: 0;\n  font-size: 13px;\n  /* TODO It should be 18px but computed line-height is stuck to min. 18.5px. Investigate that. */\n  line-height: 19px;\n  padding: ${p => (p.$hasIcon ? PADDING_WITH_ICON[p.$size] : PADDING[p.$size])};\n  vertical-align: center;\n  width: 100%;\n\n  ::placeholder {\n    color: ${p => (p.$isLight ? p.theme.color.slateGray : p.theme.color.slateGray)};\n  }\n\n  :hover {\n    border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueYonder[100])} !important;\n  }\n\n  :active,\n  :focus {\n    border: solid 1px ${p => (p.$hasError ? p.theme.color.maximumRed : p.theme.color.blueGray[100])} !important;\n    outline: 0;\n  }\n`\n\nconst InputBox = styled.div<{\n  $size: Size\n}>`\n  position: relative;\n  width: 100%;\n\n  > .Element-IconBox {\n    position: absolute;\n    right: 10px;\n    top: ${p => (p.$size === Size.LARGE ? '10px' : '5px')};\n  }\n`\n"],"names":[],"sourceRoot":""}